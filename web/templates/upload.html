<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Context Uploader</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            min-height: 100vh;
        }
        .left-panel {
            flex: 1;
            padding: 20px;
            background-color: #f4f4f4;
            border-right: 1px solid #ccc;
        }
        .right-panel {
            flex: 1;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        .form-container {
            width: 100%;
        }
        .query-form-container {
            flex-grow: 1; /* Allows this section to fill available space */
            display: flex;
            flex-direction: column;
        }
        .query-conversation {
            flex-grow: 1;
            overflow-y: auto; /* Makes this area scrollable */
            padding: 10px;
            border: 1px solid #ccc;
            background-color: #fff;
            margin-bottom: 10px;
            border-radius: 5px;
        }
        .query-form {
            display: flex;
            gap: 10px;
        }
        .query-form input {
            flex-grow: 1;
        }
        .mic-btn {
            width: 42px;
            height: 42px;
            border-radius: 50%;
            border: 1px solid #aaa;
            background: #fff;
            cursor: pointer;
        }
        .mic-btn.recording {
            background: #ffdddd;
            border-color: #ff6b6b;
        }
        .upload-form-container {
            align-self: flex-end;
            text-align: center;
        }
        input, button {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .message-user {
            background-color: #e0e0e0;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            text-align: right;
        }
        .message-bot {
            background-color: #d1e7dd;
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 5px;
            text-align: left;
        }
    </style>
</head>
<body>

    <div class="left-panel">
        <h2>JSON Content</h2>
        <div id="json-meta"></div>
        <h3>Functions</h3>
        <ul id="json-functions"></ul>
        <h3>Raw JSON</h3>
        <pre id="json-content"></pre>
    </div>

    <div class="right-panel">
        <div class="form-container query-form-container">
            <h3>Query Interface</h3>
            <div id="query-conversation" class="query-conversation">
                </div>
            <form id="query-form" class="query-form">
                <input type="text" id="query-input" placeholder="Enter your query or use the mic...">
                <button type="button" id="mic-btn" class="mic-btn" title="Start/Stop voice">ðŸŽ¤</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <div class="form-container upload-form-container">
            <h3>Upload a JSON file</h3>
            <form id="upload-form">
                <input type="file" name="file" id="file-input" accept=".json">
                <button type="submit">Upload</button>
            </form>
            <button id="save-chat-btn" style="margin-top:10px;">Save Chat</button>
        </div>
    </div>
<script>
    // Track conversation log for saving later
    const conversationLog = [];
    let sessionStart = new Date().toISOString();
    let lastParsed = null;

    // Voice input via MediaRecorder -> chunked upload -> STT backend
    let mediaRecorder = null;
    let isRecording = false;
    let sttSid = null;

    const micBtn = document.getElementById('mic-btn');
    const queryInput = document.getElementById('query-input');
    const sendBtn = document.querySelector('#query-form button[type="submit"]');

    function chooseAudioMime() {
        const options = [
            'audio/webm;codecs=opus', 'audio/webm',
            'audio/ogg;codecs=opus', 'audio/ogg'
        ];
        for (const t of options) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
        }
        return '';
    }

    function extForMime(m) {
        if (!m) return 'webm';
        if (m.includes('ogg')) return 'ogg';
        return 'webm';
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json();
            if (!res.ok || !data0.stt_sid) {
                throw new Error(data0.error || 'Failed to start STT session');
            }
            sttSid = data0.stt_sid;
            if (sendBtn) sendBtn.disabled = true;

            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try {
                        // Just send the chunk, don't expect a transcription back
                        await fetch('/stt/chunk', { method: 'POST', body: fd });
                    } catch (err) { console.error('Chunk upload failed', err); }
                }
            });

            mediaRecorder.start(2000); // Send a chunk every 2 seconds
            isRecording = true;
            micBtn.classList.add('recording');
            queryInput.placeholder = "Recording... Click mic to stop.";
        } catch (err) {
            console.error('Mic error:', err);
            alert('Unable to access microphone: ' + err.message);
        }
    }

    async function stopRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;

        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        micBtn.classList.remove('recording');
        if (sendBtn) sendBtn.disabled = false;
        queryInput.placeholder = "Finalizing transcription...";

        try {
            const res = await fetch('/stt/stop', { method: 'POST' });
            const data = await res.json();
            if (data.text) {
                queryInput.value = data.text;
                sendBtn.click(); // Automatically submit the form
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (e) {
            console.error('Failed to stop STT session:', e);
            alert('An error occurred while finalizing transcription.');
        } finally {
            queryInput.placeholder = "Enter your query or use the mic...";
            mediaRecorder = null;
            sttSid = null;
        }
    }

    micBtn?.addEventListener('click', async () => {
        if (!isRecording) await startRecording(); else await stopRecording();
    });

 
    document.getElementById('upload-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select a file.");
                return;
            }

            //display raw json
            const reader = new FileReader();
            reader.onload = function(event) {
                const rawText = event.target.result;
                document.getElementById('json-content').textContent = rawText;
            };
            reader.onerror = function(event) {
                alert("Error reading: " + event.target.error.name);
            };
            reader.readAsText(file);

            //send to backend for JSON parsing and UI hydration
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_json', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('JSON parse error:', data.error);
                    alert('JSON parse error: ' + data.error);
                    return;
                }
                console.log(data.message);
                lastParsed = data.parsed;
                // Populate left side meta and functions
                const metaDiv = document.getElementById('json-meta');
                metaDiv.innerHTML = '';
                const idP = document.createElement('p');
                idP.textContent = 'ID: ' + (lastParsed.id || '(none)');
                const qP = document.createElement('p');
                qP.textContent = 'Question: ' + (lastParsed.questionText || '');
                metaDiv.appendChild(idP);
                metaDiv.appendChild(qP);

                const fnList = document.getElementById('json-functions');
                fnList.innerHTML = '';
                (lastParsed.functions || []).forEach(fn => {
                    const li = document.createElement('li');
                    li.textContent = `${fn.name || '(unnamed)'} â€” ${fn.description || ''}`;
                    fnList.appendChild(li);
                });

                // Auto-submit the question into the chat
                const q = (lastParsed.questionText || '').trim();
                if (q) {
                    const queryInput = document.getElementById('query-input');
                    queryInput.value = q;
                    document.querySelector('#query-form button[type="submit"]').click();
                }
            })
            .catch(error => {
                console.error('Error during backend JSON upload:', error);
            });
        });

        document.getElementById('query-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const queryInput = document.getElementById('query-input');
            const query = queryInput.value.trim();
            if (!query) return;

            // Display user message
            const conversation = document.getElementById('query-conversation');
            const userMessage = document.createElement('div');
            userMessage.className = 'message-user';
            userMessage.textContent = query;
            conversation.appendChild(userMessage);
            conversation.scrollTop = conversation.scrollHeight;

            // Log turn
            conversationLog.push({
                turn: conversationLog.length + 1,
                role: 'user',
                inputType: 'text',
                content: query,
                timestamp: new Date().toISOString()
            });

            // Clear input
            queryInput.value = '';

            //send query to backend
            const queryData = new FormData();
            queryData.append('query', query);

            fetch ('/query', {
                method: 'POST',
                body: queryData
            })
            .then(response => response.json())
            .then(data => {
                // Display bot response
                const botMessage = document.createElement('div');
                botMessage.className = 'message-bot';
                botMessage.textContent = data.response || (data.error ? ('Error: ' + data.error) : '');
                conversation.appendChild(botMessage);
                conversation.scrollTop = conversation.scrollHeight;

                // Log bot turn
                conversationLog.push({
                    turn: conversationLog.length + 1,
                    role: 'assistant',
                    inputType: 'model',
                    content: botMessage.textContent,
                    timestamp: new Date().toISOString()
                });
            })
            .catch(error => {
                console.error('Error during backend query:', error);
            });
        });

        // Save chat button handler
        document.getElementById('save-chat-btn').addEventListener('click', function() {
            const payload = {
                sessionInfo: {
                    sessionId: crypto.randomUUID(),
                    userId: 'anonymous',
                    startTimestamp: sessionStart,
                    endTimestamp: new Date().toISOString(),
                    llmModel: 'gemini-1.5-flash-latest'
                },
                context: {
                    initialContent: lastParsed?.questionText || '',
                    finalContent: conversationLog.length ? conversationLog[conversationLog.length - 1].content : ''
                },
                conversationLog: conversationLog,
                evaluation: {
                    surveyResponses: {},
                    userComments: ''
                }
            };
            fetch('/save_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(d => {
                if (d.error) {
                    alert('Failed to save: ' + d.error);
                } else {
                    alert('Saved: ' + d.dirName);
                }
            })
            .catch(err => {
                alert('Save error: ' + err);
            });
        });
</script>
</body>
</html>