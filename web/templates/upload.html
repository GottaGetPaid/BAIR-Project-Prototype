<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    
</head>
<body>
    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner"><strong>Your voice will be recorded for training purposes.</strong></div>
    <!-- Start Screen -->
    <section id="start-screen">
        <div class="top-bar" style="padding: 12px 16px;">
            <div></div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">🌙</button>
        </div>
        <div class="center-hero">
            <div>
                <div class="hero-title">Welcome to Blanca</div>
                <div class="hero-tagline subtle">Please use the microphone to begin your prompt. Below are some of the possible topics you can ask and an example question.</div>
                <div id="start-tool-grid" class="tool-grid"></div>
                <div id="start-sample-prompt" class="sample-prompt-text subtle" style="margin-top:12px; text-align:center;"></div>
            </div>
        </div>
        <div class="start-input-bar">
            <div class="start-input">
                <button id="start-upload-btn" class="icon-btn" title="Upload JSON">📄</button>
                <input id="start-query-input" placeholder="Ask a question or upload a JSON..." />
                <button id="start-mic-btn" class="icon-btn" title="Voice input">🎤</button>
                <button id="start-send-btn" class="send-btn">Send</button>
                <input id="start-file-input" type="file" accept=".json,.jsonl" class="hidden" />
            </div>
        </div>
    </section>

    <!-- Main App (two panels) -->
    <div class="main-container hidden" id="main-app">
        <div class="left-panel">
        <div class="top-bar">
            <div class="lhs-intro">
                <div class="title">Please continue your conversation using the microphone.</div>
                <div class="subtle">Below are some related topics you can explore.</div>
            </div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">🌙</button>
        </div>
        <div id="json-meta"></div>
        <div id="entry-list-container" class="hidden">
            <div class="section-title">JSON Entries</div>
            <div id="entry-list"></div>
        </div>

    <div id="function-ideas-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Function Ideas</div>
        <div id="function-ideas-grid" class="function-ideas-grid"></div>
    </div>

    <div id="latest-prompt-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Your Prompt</div>
        <div id="latest-prompt-content" class="latest-prompt-callout"></div>
    </div>

    <div id="followup-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Suggested Follow-ups</div>
        <ul id="followup-list" class="followup-list"></ul>
    </div>

    <div id="question-display" style="margin-top: auto;"></div>
    <div class="section-title inline-controls"><span>Tools</span></div>
    <div id="toolbox-view-left"></div>

    <div id="related-topics-panel" class="hidden" style="margin-top: 12px;">
        <div class="section-title">Related Topics</div>
        <div id="related-topics-list" class="related-topics-list"></div>
    </div>
    </div>

    <div id="resizer"></div>

    <div class="right-panel">
        <div class="form-container query-form-container">
            <h3>Query Interface</h3>
            <div id="query-conversation" class="query-conversation">
                </div>
            <form id="query-form" class="query-form">
                <input type="text" id="query-input" placeholder="Enter your query or use the mic...">
                <button type="button" id="mic-btn" class="mic-btn" title="Start/Stop voice">🎤</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <div class="form-container upload-form-container">
            <h3>Upload a JSON or JSONL file</h3>
            <form id="upload-form">
                <input type="file" name="file" id="file-input" accept=".json,.jsonl">
                <button type="submit" class="btn btn-primary">Upload</button>
            </form>
            <button id="save-chat-btn" class="btn" style="margin-top:10px;">Save Chat</button>
        </div>
    </div>
</div>

    <!-- Floating Tools button -->
    <!-- <button id="tools-fab" class="icon-btn" title="Tools & Raw JSON">🧰</button> -->

    <!-- Modal for Tools & Raw JSON -->
    <div id="tools-modal" class="modal-backdrop" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Tools & Raw JSON</div>
                <button id="tools-modal-close" class="icon-btn" aria-label="Close">✖</button>
            </div>
            <div class="section-title">Capabilities</div>
            <div class="tool-grid" style="margin-bottom:10px;">
                <div class="tool-card"><h4>Travel</h4><p>Flights, hotels, itineraries</p></div>
                <div class="tool-card"><h4>Science</h4><p>Facts, summaries, lookups</p></div>
                <div class="tool-card"><h4>Math</h4><p>Arithmetic, primes, series</p></div>
                <div class="tool-card"><h4>Trivia</h4><p>General knowledge Q&A</p></div>
            </div>
            <div class="section-title inline-controls">
                <span>Raw JSON</span>
                <button id="toggle-raw-btn" class="btn btn-ghost" style="padding: 4px 8px; font-size: 12px;">Show</button>
            </div>
            <pre id="json-content" class="hidden"></pre>
        </div>
    </div>
<script>
    // Theme handling
    (function initTheme(){
        const saved = localStorage.getItem('theme') || 'light';
        if (saved === 'dark') document.documentElement.setAttribute('data-theme','dark');
        const buttons = document.querySelectorAll('#theme-toggle');
        const setIcon = (btn) => { if (!btn) return; btn.textContent = document.documentElement.getAttribute('data-theme') === 'dark' ? '☀️' : '🌙'; };
        buttons.forEach(setIcon);
        document.addEventListener('click', (e)=>{
            if (e.target && e.target.id === 'theme-toggle'){
                const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = cur === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', next === 'dark' ? 'dark' : '');
                localStorage.setItem('theme', next);
                document.querySelectorAll('#theme-toggle').forEach(setIcon);
            }
        });
    })();

    // Track conversation log for saving later
    const conversationLog = [];
    let sessionStart = new Date().toISOString();
    let lastParsed = null;
    let allEntries = []; // Global store for unique entries
    let lastRawText = '';
    let functionIndex = []; // flattened functions with vectors for similarity
    let startSamplePrompt = '';
    let latestUserPrompt = '';
    let lastUserQueryText = '';
    const relatedTopicsState = { topics: [], followUps: [], source: 'none' };
    let keywordTopicIndex = [];
    let keywordTopicItems = [];
    let relatedFetchToken = 0;

    // Modal handling and raw JSON toggler (modal)
    const toolsFab = document.getElementById('tools-fab');
    const toolsModal = document.getElementById('tools-modal');
    const toolsModalClose = document.getElementById('tools-modal-close');
    const rawPre = document.getElementById('json-content');
    const rawBtn = document.getElementById('toggle-raw-btn');
    if (toolsFab && toolsModal && toolsModalClose) {
        toolsFab.addEventListener('click', ()=>{ toolsModal.classList.add('show'); });
        toolsModalClose.addEventListener('click', ()=>{ toolsModal.classList.remove('show'); });
        toolsModal.addEventListener('click', (e)=>{ if (e.target === toolsModal) toolsModal.classList.remove('show'); });
    }
    if (rawBtn && rawPre) {
        rawBtn.addEventListener('click', ()=>{
            const hidden = rawPre.classList.toggle('hidden');
            rawBtn.textContent = hidden ? 'Show' : 'Hide';
        });
    }

    // Transition from start screen to main app
    const startScreen = document.getElementById('start-screen');
    const mainApp = document.getElementById('main-app');
    function transitionToMain(){
        if (mainApp.classList.contains('hidden')){
            startScreen.classList.add('fade-out');
            setTimeout(()=>{ startScreen.style.display = 'none'; mainApp.classList.remove('hidden'); }, 200);
        }
    }
    // --- Start screen topics and sample prompt ---
    const ALL_TOPICS = [
        { title: 'Travel', desc: 'Flights, hotels, itineraries' },
        { title: 'Science', desc: 'Facts, summaries, lookups' },
        { title: 'Math', desc: 'Arithmetic, primes, series' },
        { title: 'Trivia', desc: 'General knowledge Q&A' },
        { title: 'Shopping', desc: 'Compare prices, find deals' },
        { title: 'Coding', desc: 'APIs, debugging, snippets' },
        { title: 'Health', desc: 'Wellness info, nutrition' },
        { title: 'Finance', desc: 'Budgets, markets, taxes' },
        { title: 'News', desc: 'Headlines, summaries' },
        { title: 'Education', desc: 'Study help, quizzes' },
        { title: 'Sports', desc: 'Scores, schedules, stats' },
        { title: 'Weather', desc: 'Forecasts and advisories' }
    ];
    const SAMPLE_PROMPTS = [
        'Find flights from SFO to NYC next Tuesday under $300 and a 2-night hotel near Times Square.',
        'Summarize the key differences between mitosis and meiosis with examples.',
        'Write a function to compute the nth Fibonacci number and show the first 10.',
        'What is the capital of Brazil and two facts about it?',
        'Compare the MacBook Air M2 vs. Dell XPS 13 for programming and battery life.'
    ];
    const TOPIC_SYNONYM_MAP = {
        physics: ['physics', 'mechanics', 'mechanic', 'quantum', 'gravity', 'force', 'forces', 'energy', 'motion', 'optics', 'electromagnetism', 'relativity', 'thermodynamics', 'waves'],
        search: ['search', 'lookup', 'google', 'bing', 'find', 'discover', 'locate', 'query', 'information', 'research'],
        trivia: ['trivia', 'facts', 'fact', 'quiz', 'questions', 'curiosity', 'knowledge'],
        math: ['math', 'mathematics', 'algebra', 'geometry', 'calculus', 'statistics', 'arithmetic', 'numbers', 'equations'],
        weather: ['weather', 'forecast', 'temperature', 'rain', 'climate', 'conditions', 'storm', 'humidity'],
        finance: ['finance', 'stocks', 'markets', 'budget', 'investing', 'investment', 'money', 'economy', 'economic'],
        coding: ['coding', 'programming', 'debug', 'debugging', 'code', 'software', 'api', 'development', 'compute'],
        travel: ['travel', 'trip', 'journey', 'flights', 'flight', 'hotel', 'vacation', 'itinerary', 'tourism'],
        health: ['health', 'wellness', 'nutrition', 'fitness', 'exercise', 'diet', 'medical', 'medicine'],
        sports: ['sports', 'game', 'games', 'scores', 'athletics', 'leagues', 'teams', 'tournament'],
        news: ['news', 'headlines', 'breaking', 'articles', 'media', 'press', 'reports', 'reporting'],
        education: ['education', 'study', 'learning', 'school', 'teaching', 'quiz', 'lesson', 'class']
    };
    function pickRandom(arr, n){
        const a = arr.slice();
        for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
        return a.slice(0, n);
    }
    function renderStartTopics(){
        const grid = document.getElementById('start-tool-grid');
        if (!grid) return;
        grid.innerHTML = '';
        pickRandom(ALL_TOPICS, 4).forEach(t => {
            const card = document.createElement('div');
            card.className = 'tool-card';
            const h4 = document.createElement('h4'); h4.textContent = t.title;
            const p = document.createElement('p'); p.textContent = t.desc;
            card.appendChild(h4); card.appendChild(p);
            grid.appendChild(card);
        });
        startSamplePrompt = pickRandom(SAMPLE_PROMPTS, 1)[0] || '';
        const sampleEl = document.getElementById('start-sample-prompt');
        if (sampleEl) sampleEl.textContent = startSamplePrompt ? `Try: “${startSamplePrompt}”` : '';
    }
    // Render at load
    renderStartTopics();
    fetch('{{ url_for('static', filename='data/example_functions.json') }}')
        .then(r=>r.json())
        .then(data => { if (data && Array.isArray(data.topics)) buildKeywordTopicIndex(data.topics); })
        .catch(err => console.warn('Failed to load topic catalog', err));
    // Start screen controls (send, mic, upload)
    const startQueryInput = document.getElementById('start-query-input');
    const startSendBtn = document.getElementById('start-send-btn');
    const startMicBtn = document.getElementById('start-mic-btn');
    const startUploadBtn = document.getElementById('start-upload-btn');
    const startFileInput = document.getElementById('start-file-input');

    startSendBtn?.addEventListener('click', ()=>{
        const q = (startQueryInput.value || '').trim(); if (!q) return;
        transitionToMain();
        document.getElementById('query-input').value = q;
        updateLatestPromptPanel(q);
        refreshRelatedSuggestions(q);
        document.querySelector('#query-form button[type="submit"]').click();
    });
    
    // Add Enter key support for start screen
    startQueryInput?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const q = (startQueryInput.value || '').trim(); if (!q) return;
            transitionToMain();
            document.getElementById('query-input').value = q;
            updateLatestPromptPanel(q);
            refreshRelatedSuggestions(q);
            document.querySelector('#query-form button[type="submit"]').click();
        }
    });
    startUploadBtn?.addEventListener('click', ()=> startFileInput.click());
    startFileInput?.addEventListener('change', function(){
        const file = this.files && this.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev){
            lastRawText = ev.target.result || '';
            if (rawPre) rawPre.textContent = lastRawText;
        };
        reader.readAsText(file);
        const fd = new FormData(); fd.append('file', file);
        fetch('/upload_json', { method: 'POST', body: fd })
          .then(r=>r.json()).then(data=>{
            if (data.error) return alert('JSON parse error: ' + data.error);
            const entries = data.parsed_list || (data.parsed ? [data.parsed] : []);
            if (!entries.length) return;
            entries.forEach(newEntry => {
                if (newEntry.id && !allEntries.some(existing => existing.id === newEntry.id)) {
                    allEntries.push(newEntry);
                }
            });
            renderEntryList();
            renderToolboxView();
            transitionToMain();
            // Auto-submit first entry
            const first = allEntries[0];
            if (first && first.questionText){
                document.getElementById('query-input').value = first.questionText;
                renderEntry(first);
                updateLatestPromptPanel(first.questionText);
                refreshRelatedSuggestions(first.questionText);
                document.querySelector('#query-form button[type="submit"]').click();
            }
          }).catch(err=> alert('Error during backend JSON upload: ' + err));
    });

    // Start screen Deepgram streaming functions
    let startSocket, startMicrophone, startProcessor;
    let startHasFinalTranscript = false;
    
    async function startScreenDeepgramStreaming() {
        isRecording = true;
        startHasFinalTranscript = false;
        startMicBtn.classList.add('recording');
        startQueryInput.placeholder = "🎤 Listening... Speak now!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            startMicrophone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            startSocket = new WebSocket(wsUrl);

            startSocket.onopen = async () => {
                console.log('Start screen WebSocket connected for Deepgram streaming.');
                try {
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/ogg;codecs=opus';
                    
                    const mediaRecorder = new MediaRecorder(startMicrophone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && startSocket.readyState === WebSocket.OPEN) {
                            startSocket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.start(250);
                    startProcessor = mediaRecorder;
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    startSocket.close();
                }
            };

            startSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.transcript) {
                        startQueryInput.value = data.transcript;
                        console.log('[Start screen] Transcript:', data.transcript, 'Final:', !data.interim);
                        
                        if (data.interim) {
                            startQueryInput.style.fontStyle = 'italic';
                            startQueryInput.style.opacity = '0.8';
                        } else {
                            startQueryInput.style.fontStyle = 'normal';
                            startQueryInput.style.opacity = '1';
                            startHasFinalTranscript = true;
                            
                            // Auto-submit on final transcript - don't wait for user to click mic again
                            console.log('[Start screen] Got final transcript, auto-submitting...');
                            setTimeout(() => {
                                stopStartScreenDeepgramStreaming();
                            }, 500);
                        }
                    } else if (data.llm_response) {
                        // Ignore LLM interjections on start screen
                        console.log('[Start screen] Ignoring LLM interjection:', data.llm_response);
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            startSocket.onclose = (event) => {
                console.log('Start screen WebSocket closed:', event.code, event.reason);
            };
            
            startSocket.onerror = (err) => {
                console.error('Start screen WebSocket error:', err);
                if (isRecording) {
                    stopStartScreenDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Start screen mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopStartScreenDeepgramStreaming();
        }
    }

    async function stopStartScreenDeepgramStreaming() {
        console.log('[Start screen] Stopping, has final transcript:', startHasFinalTranscript, 'Input value:', startQueryInput.value);
        
        // Stop audio first
        if (startProcessor && startProcessor.stop) startProcessor.stop();
        if (startMicrophone) startMicrophone.getTracks().forEach(track => track.stop());
        isRecording = false;
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing...";
        startQueryInput.style.fontStyle = 'normal';
        startQueryInput.style.opacity = '1';
        
        // Wait longer for final transcript to arrive from WebSocket before closing it
        setTimeout(() => {
            if (startSocket) startSocket.close();
            startSocket = startMicrophone = startProcessor = null;
            
            // Auto-submit if we have text
            const text = startQueryInput.value.trim();
            console.log('[Start screen] Ready to submit, text:', text);
            if (text) {
                startQueryInput.placeholder = "Submitting...";
                startSendBtn.click();
            } else {
                startQueryInput.placeholder = "Ask a question or upload a JSON...";
            }
        }, 800);
    }
    
    // Start screen chunked recording functions
    async function startScreenChunkedRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json(); 
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid; 
            isRecording = true; 
            startMicBtn.classList.add('recording');
            startQueryInput.placeholder = "Recording... Click mic to stop.";
            
            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch {}
                }
            });
            mediaRecorder.start(2000);
        } catch (err) { 
            alert('Unable to access microphone: ' + err.message); 
        }
    }
    
    async function stopStartScreenChunkedRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false; 
        mediaRecorder.stop(); 
        mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing transcription...";
        
        try { 
            const res2 = await fetch('/stt/stop', { method: 'POST' }); 
            const data = await res2.json(); 
            if (data.text) { 
                startQueryInput.value = data.text;
                // Auto-submit after transcription completes
                startSendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (err) {
            console.error('Failed to stop STT session:', err);
            alert('An error occurred while finalizing transcription.');
        } finally {
            startQueryInput.placeholder = "Ask a question or upload a JSON...";
            mediaRecorder = null;
            sttSid = null;
        }
    }
    
    // Start screen mic button - checks backend and routes appropriately
    startMicBtn?.addEventListener('click', async ()=>{
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopStartScreenDeepgramStreaming(); 
            else await startScreenDeepgramStreaming();
        } else {
            if (isRecording) await stopStartScreenChunkedRecording(); 
            else await startScreenChunkedRecording();
        }
    });
    // --- Voice Input: Conditional logic for STT backend ---
    const sttBackend = '{{ stt_backend }}';
    const micBtn = document.getElementById('mic-btn');
    const queryInput = document.getElementById('query-input');
    const sendBtn = document.querySelector('#query-form button[type="submit"]');

    let isRecording = false;

    // --- Logic for Deepgram Streaming STT ---
    let socket;
    let microphone;
    let processor;

    async function startDeepgramStreaming() {
        isRecording = true;
        micBtn.classList.add('recording');
        queryInput.placeholder = "🎤 Starting real-time conversation... Speak naturally!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            socket = new WebSocket(wsUrl);

            socket.onopen = async () => {
                console.log('WebSocket connected for Deepgram streaming.');
                try {
                    // Use MediaRecorder with a more compatible format
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/ogg;codecs=opus';
                    }
                    
                    const mediaRecorder = new MediaRecorder(microphone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
                            console.log('Sending audio chunk, size:', event.data.size);
                            socket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                    };
                    
                    mediaRecorder.start(250); // Send chunks every 250ms for better stability and less load
                    processor = mediaRecorder; // Store reference for cleanup
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    socket.close();
                }
            };

            socket.onmessage = (event) => {
                console.log('Received WebSocket message:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.transcript) {
                        // Real-time transcript updates
                        queryInput.value = data.transcript;
                        
                        // Visual feedback for interim vs final results
                        if (data.interim) {
                            queryInput.style.fontStyle = 'italic';
                            queryInput.style.opacity = '0.8';
                        } else {
                            queryInput.style.fontStyle = 'normal';
                            queryInput.style.opacity = '1';
                            // Don't add user message here - wait for LLM response
                        }
                        
                        console.log('Real-time transcript:', data.transcript, data.interim ? '(interim)' : '(final)');
                        
                    } else if (data.llm_response) {
                        // LLM interjected with a response
                        console.log('LLM interjection:', data.llm_response);
                        
                        const conversation = document.getElementById('query-conversation');
                        
                        // First add the user message (the complete transcript that triggered the response)
                        if (queryInput.value.trim()) {
                            const userMessage = document.createElement('div');
                            userMessage.className = 'message-user';
                            userMessage.textContent = queryInput.value.trim();
                            conversation.appendChild(userMessage);
                        }
                        
                        // Then add LLM response
                        const botMessage = document.createElement('div');
                        botMessage.className = 'message-bot';
                        botMessage.textContent = data.llm_response;
                        conversation.appendChild(botMessage);
                        conversation.scrollTop = conversation.scrollHeight;
                        
                        // Clear the input to continue listening for new speech
                        queryInput.value = '';
                        queryInput.placeholder = '🎤 Continue speaking... AI is listening';
                        
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                        queryInput.placeholder = '🎤 Real-time conversation active - speak naturally!';
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            socket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                if (isRecording) {
                    console.log('WebSocket closed unexpectedly during recording');
                    // Don't auto-reconnect, let user restart manually
                }
            };
            socket.onerror = (err) => {
                console.error('WebSocket error:', err);
                if (isRecording) {
                    console.log('WebSocket error during recording, stopping...');
                    stopDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopDeepgramStreaming(); // Cleanup on error
        }
    }

    async function stopDeepgramStreaming() {
        if (socket) socket.close();
        if (processor && processor.stop) processor.stop(); // Stop MediaRecorder
        if (microphone) microphone.getTracks().forEach(track => track.stop());
        isRecording = false;
        micBtn.classList.remove('recording');
        queryInput.placeholder = "Enter your query or use the mic...";
        
        // End the conversation session
        console.log('Ending real-time conversation session');
        queryInput.placeholder = "Real-time conversation ended. Click mic to start again.";
        
        socket = microphone = processor = null;
    }

    // --- Logic for chunked recording (Whisper/Gemini) ---
    let mediaRecorder = null;
    let sttSid = null;

    function chooseAudioMime() {
        const options = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'];
        for (const t of options) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
        }
        return '';
    }

    function extForMime(m) {
        if (!m) return 'webm';
        if (m.includes('ogg')) return 'ogg';
        return 'webm';
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json();
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid;
            if (sendBtn) sendBtn.disabled = true;

            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch (err) { console.error('Chunk upload failed', err); }
                }
            });

            mediaRecorder.start(2000);
            isRecording = true;
            micBtn.classList.add('recording');
            queryInput.placeholder = "Recording... Click mic to stop.";
        } catch (err) {
            console.error('Mic error:', err);
            alert('Unable to access microphone: ' + err.message);
        }
    }

    async function stopRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        micBtn.classList.remove('recording');
        if (sendBtn) sendBtn.disabled = false;
        queryInput.placeholder = "Finalizing transcription...";

        try {
            const res = await fetch('/stt/stop', { method: 'POST' });
            const data = await res.json();
            if (data.text) {
                queryInput.value = data.text;
                sendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (e) {
            console.error('Failed to stop STT session:', e);
            alert('An error occurred while finalizing transcription.');
        } finally {
            queryInput.placeholder = "Enter your query or use the mic...";
            mediaRecorder = null;
            sttSid = null;
        }
    }

    // Main mic button event listener
    micBtn?.addEventListener('click', async () => {
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopDeepgramStreaming(); else await startDeepgramStreaming();
        } else {
            if (isRecording) await stopRecording(); else await startRecording();
        }
    });

 
    document.getElementById('upload-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select a file.");
                return;
            }

            //display raw json (modal)
            const reader = new FileReader();
            reader.onload = function(event) {
                const rawText = event.target.result; lastRawText = rawText || '';
                if (rawPre) rawPre.textContent = rawText;
            };
            reader.onerror = function(event) {
                alert("Error reading: " + event.target.error.name);
            };
            reader.readAsText(file);

            //send to backend for JSON parsing and UI hydration
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_json', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('JSON parse error:', data.error);
                    alert('JSON parse error: ' + data.error);
                    return;
                }
                console.log(data.message);
                const entries = data.parsed_list || (data.parsed ? [data.parsed] : []);
                if (!entries.length) return;

                // Merge new entries, ensuring no duplicates based on ID
                let newEntriesAdded = false;
                entries.forEach(newEntry => {
                    if (newEntry.id && !allEntries.some(existing => existing.id === newEntry.id)) {
                        allEntries.push(newEntry);
                        newEntriesAdded = true;
                    }
                });

                renderEntryList();
                renderToolboxView(); // Render tools to the left panel

                // If this is the first upload or new entries were added,
                // render the details of the first overall entry.
                if (allEntries.length > 0 && newEntriesAdded) {
                    const first = allEntries[0];
                    renderEntry(first);
                    if (first?.questionText) {
                        updateLatestPromptPanel(first.questionText);
                        refreshRelatedSuggestions(first.questionText);
                    }
                    // Highlight the first entry button as active
                    const firstBtn = document.querySelector('.entry-btn');
                    if(firstBtn) firstBtn.classList.add('active');
                }
            })
            .catch(error => {
                console.error('Error during backend JSON upload:', error);
            });
        });

        document.getElementById('query-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const queryInput = document.getElementById('query-input');
            const query = queryInput.value.trim();
            if (!query) return;
            lastUserQueryText = query;

            // Display user message
            const conversation = document.getElementById('query-conversation');
            const userMessage = document.createElement('div');
            userMessage.className = 'message-user';
            userMessage.textContent = query;
            conversation.appendChild(userMessage);
            conversation.scrollTop = conversation.scrollHeight;

            // Log turn
            conversationLog.push({
                turn: conversationLog.length + 1,
                role: 'user',
                inputType: 'text',
                content: query,
                timestamp: new Date().toISOString()
            });

            // Clear input
            queryInput.value = '';

            // Update left rail context
            updateLatestPromptPanel(query);
            refreshRelatedSuggestions(query);

            //send query to backend
            const queryData = new FormData();
            queryData.append('query', query);

            fetch ('/query', {
                method: 'POST',
                body: queryData
            })
            .then(response => response.json())
            .then(data => {
                // Display bot response
                const botMessage = document.createElement('div');
                botMessage.className = 'message-bot';
                botMessage.textContent = data.response || (data.error ? ('Error: ' + data.error) : '');
                conversation.appendChild(botMessage);
                conversation.scrollTop = conversation.scrollHeight;

                // Log bot turn
                conversationLog.push({
                    turn: conversationLog.length + 1,
                    role: 'assistant',
                    inputType: 'model',
                    content: botMessage.textContent,
                    timestamp: new Date().toISOString()
                });
            })
            .catch(error => {
                console.error('Error during backend query:', error);
            });
        });

        // Save chat button handler
        function renderEntryList() {
            const entryListContainer = document.getElementById('entry-list-container');
            const entryList = document.getElementById('entry-list');
            entryList.innerHTML = '';

            if (allEntries.length > 1) {
                entryListContainer.classList.remove('hidden');
            } else {
                entryListContainer.classList.add('hidden');
            }

            allEntries.forEach((entry, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'entry-item-wrapper';

                const btn = document.createElement('button');
                btn.textContent = entry.id || `Entry ${index + 1}`;
                btn.className = 'btn entry-btn';
                btn.dataset.entryId = entry.id;
                btn.addEventListener('click', () => {
                    renderEntry(entry);
                    document.querySelectorAll('.entry-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });

                const removeBtn = document.createElement('button');
                removeBtn.textContent = '×';
                removeBtn.className = 'btn-remove-entry';
                removeBtn.title = 'Remove entry';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent the main button click
                    allEntries = allEntries.filter(e => e.id !== entry.id);
                    renderEntryList();
                    renderToolboxView(); // Re-render tools in left panel
                    // Optional: Clear the view if the active entry was removed
                    if (lastParsed && lastParsed.id === entry.id) {
                        document.getElementById('json-meta').innerHTML = '';
                        document.getElementById('question-display').innerHTML = '';
                        if (rawPre) rawPre.textContent = '';
                        lastParsed = null;
                    }
                });

                wrapper.appendChild(btn);
                wrapper.appendChild(removeBtn);
                entryList.appendChild(wrapper);
            });
        }

        document.getElementById('save-chat-btn').addEventListener('click', function() {
            const payload = {
                sessionInfo: {
                    sessionId: crypto.randomUUID(),
                    userId: 'anonymous',
                    startTimestamp: sessionStart,
                    endTimestamp: new Date().toISOString(),
                    llmModel: 'gemini-1.5-flash-latest'
                },
                context: {
                    initialContent: lastParsed?.questionText || '',
                    finalContent: conversationLog.length ? conversationLog[conversationLog.length - 1].content : ''
                },
                conversationLog: conversationLog,
                evaluation: {
                    surveyResponses: {},
                    userComments: ''
                }
            };
            fetch('/save_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(d => {
                if (d.error) {
                    alert('Failed to save: ' + d.error);
                } else {
                    alert('Saved: ' + d.dirName);
                }
            })
            .catch(err => {
                alert('Save error: ' + err);
            });
        });

        function renderEntry(entry) {
            lastParsed = entry;

            // Clear previous meta content
            document.getElementById('json-meta').innerHTML = '';

            // Populate the new question display area at the bottom
            const questionDiv = document.getElementById('question-display');
            questionDiv.innerHTML = ''; // Clear previous question
            const qP = document.createElement('p');
            qP.innerHTML = `<strong>Question:</strong><br>${entry.questionText || ''}`;
            questionDiv.appendChild(qP);

            const submitBtn = document.createElement('button');
            submitBtn.textContent = 'Submit Question to Chat';
            submitBtn.className = 'btn submit-question-btn';
            submitBtn.addEventListener('click', () => {
                const q = (entry.questionText || '').trim();
                if (q) {
                    document.getElementById('query-input').value = q;
                    document.querySelector('#query-form button[type="submit"]').click();
                }
            });
            questionDiv.appendChild(submitBtn);

            // Update raw JSON view in modal if raw present
            if (entry.raw && rawPre) { rawPre.textContent = JSON.stringify(entry.raw, null, 2); }
            // The toolbox is now global and does not need to be re-rendered on entry selection.
        }

        function renderToolboxView(){
            const functions = [];
            allEntries.forEach(entry => {
                (entry.functions || []).forEach(func => {
                    functions.push({ ...func, entryId: entry.id });
                });
            });

            // Build function index with vectors for similarity
            functionIndex = functions.map(fn => {
                const full = (fn.name || '').trim();
                let toolbox = 'misc';
                let tool = full || '(unnamed)';
                if (full.includes('.')){
                    const idx = full.indexOf('.');
                    toolbox = full.slice(0, idx) || 'misc';
                    tool = full.slice(idx+1) || '(unnamed)';
                }
                const paramNames = [];
                try {
                    const params = fn.parameters || {};
                    if (params && params.properties) {
                        for (const k of Object.keys(params.properties)) paramNames.push(k);
                    }
                } catch {}
                const text = [full, fn.description || '', paramNames.join(' ')].join(' ').toLowerCase();
                return {
                    fullName: full,
                    toolbox,
                    tool,
                    desc: fn.description || '',
                    params: fn.parameters,
                    entryId: fn.entryId,
                    triVector: trigramVector(text),
                    wordVector: wordVector(text),
                    tokens: new Set(text.split(/[^a-z0-9]+/).filter(Boolean))
                };
            });

            const container = document.getElementById('toolbox-view-left');
            container.innerHTML = '';
            if (!functions || !functions.length){
                const p = document.createElement('p'); p.className = 'subtle'; p.textContent = 'No tools found in JSON.'; container.appendChild(p); return;
            }
            const groups = {};
            for (const fi of functionIndex){
                if (!groups[fi.toolbox]) groups[fi.toolbox] = [];
                groups[fi.toolbox].push({ tool: fi.tool, desc: fi.desc, params: fi.params, entryId: fi.entryId });
            }

            const toolboxNames = Object.keys(groups).sort((a,b)=>a.localeCompare(b));
            for (const name of toolboxNames){
                const items = groups[name];
                const details = document.createElement('details');
                details.className = 'toolbox';
                const summary = document.createElement('summary');
                summary.innerHTML = `${name} <span class="badge">${items.length}</span>`;
                details.appendChild(summary);
                const ul = document.createElement('ul');
                ul.className = 'tool-list';
                for (const it of items){
                    const li = document.createElement('li');
                    const d = document.createElement('details'); d.className = 'tool';
                    const s = document.createElement('summary'); 
                    s.textContent = it.tool;

                    const entryIdSpan = document.createElement('span');
                    entryIdSpan.className = 'tool-entry-id';
                    entryIdSpan.textContent = it.entryId || '';
                    s.appendChild(entryIdSpan);

                    d.appendChild(s);
                    if (it.desc){ const desc = document.createElement('div'); desc.className = 'tool-desc'; desc.textContent = it.desc; d.appendChild(desc); }
                    if (it.params){ const pre = document.createElement('pre'); pre.className = 'tool-params'; pre.textContent = JSON.stringify(it.params, null, 2); d.appendChild(pre); }
                    li.appendChild(d);
                    ul.appendChild(li);
                }
                details.appendChild(ul);
                container.appendChild(details);
            }
            // Render function ideas
            renderFunctionIdeas();
        }

        // --- Similarity helpers (trigram + cosine) ---
        function trigramVector(text){
            const v = new Map();
            const t = (text || '').toLowerCase();
            for (let i=0;i<t.length-2;i++){
                const tri = t.slice(i,i+3);
                v.set(tri, (v.get(tri)||0)+1);
            }
            return v;
        }
        function wordVector(text){
            const v = new Map();
            const tokens = (text||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
            for (const tok of tokens){ v.set(tok, (v.get(tok)||0)+1); }
            return v;
        }
        function cosineSim(v1, v2){
            if (!v1 || !v2) return 0;
            let dot=0, norm1=0, norm2=0;
            for (const [,w] of v1) norm1 += w*w;
            for (const [,w] of v2) norm2 += w*w;
            const smaller = v1.size < v2.size ? v1 : v2;
            const other = smaller===v1 ? v2 : v1;
            for (const [k,w] of smaller){ const w2 = other.get(k)||0; if (w2) dot += w*w2; }
            if (!norm1 || !norm2) return 0;
            return dot / (Math.sqrt(norm1)*Math.sqrt(norm2));
        }
        function renderFunctionIdeas(){
            const panel = document.getElementById('function-ideas-panel');
            const grid = document.getElementById('function-ideas-grid');
            if (!functionIndex.length){ panel.classList.add('hidden'); grid.innerHTML=''; return; }
            const n = Math.min(functionIndex.length, Math.floor(Math.random()*2)+4); // 4 or 5
            const picks = pickRandom(functionIndex, n);
            grid.innerHTML = '';
            for (const fi of picks){
                const card = document.createElement('div');
                card.className = 'function-idea-card';
                const title = document.createElement('div'); title.className = 'function-idea-title'; title.textContent = `${fi.toolbox}.${fi.tool}`;
                const desc = document.createElement('div'); desc.className = 'function-idea-desc'; desc.textContent = fi.desc || '';
                card.appendChild(title); card.appendChild(desc);
                grid.appendChild(card);
            }
            panel.classList.remove('hidden');
        }
        function buildKeywordTopicIndex(topics){
            if (!Array.isArray(topics)) return;
            keywordTopicItems = topics.slice();
            keywordTopicIndex = keywordTopicItems.map(t => {
                const text = [t.title, t.description, ...(t.functions||[]).map(f=>`${f.name} ${f.description}`)].join(' ').toLowerCase();
                const synonyms = new Set((TOPIC_SYNONYM_MAP[t.id] || []).map(s => s.toLowerCase()));
                const tokens = new Set(text.split(/[^a-z0-9]+/).filter(Boolean));
                synonyms.forEach(s => tokens.add(s));
                return {
                    topic: t,
                    triVector: trigramVector(text),
                    wordVector: wordVector(text),
                    tokens,
                    synonyms
                };
            });
        }

        function keywordTopicFallback(prompt){
            const q = (prompt || '').toLowerCase();
            if (!q || !keywordTopicIndex.length) return keywordTopicItems.slice(0, 3).map(t => ({ title: t.title, description: t.description || '' }));
            const qTri = trigramVector(q);
            const qWord = wordVector(q);
            const qTokens = new Set(q.split(/[^a-z0-9]+/).filter(Boolean));
            const scored = keywordTopicIndex.map(entry => {
                const tri = cosineSim(qTri, entry.triVector);
                const word = cosineSim(qWord, entry.wordVector);
                let boost = 0;
                qTokens.forEach(tok => {
                    if (entry.tokens.has(tok)) boost += 0.04;
                    if (entry.synonyms.has(tok)) boost += 0.08;
                });
                return { entry, score: (0.6 * tri) + (0.4 * word) + boost };
            }).sort((a,b)=>b.score - a.score);
            const filtered = scored.filter(s => s.score > 0.01).slice(0, 3);
            const picks = filtered.length ? filtered : scored.slice(0, 3);
            const mapped = picks.map(item => ({
                title: item.entry.topic.title,
                description: item.entry.topic.description || ''
            })).filter(t => t.title);
            if (!mapped.length){
                return ALL_TOPICS.slice(0, 3).map(t => ({ title: t.title, description: t.desc || '' }));
            }
            return mapped;
        }

        function updateLatestPromptPanel(text){
            if (typeof text === 'string') {
                latestUserPrompt = text.trim();
            }
            const panel = document.getElementById('latest-prompt-panel');
            const content = document.getElementById('latest-prompt-content');
            if (!panel || !content) return;
            if (latestUserPrompt){
                content.textContent = latestUserPrompt;
                panel.classList.remove('hidden');
            } else {
                content.textContent = '';
                panel.classList.add('hidden');
            }
        }

        function renderFollowupExamples(followUps){
            const panel = document.getElementById('followup-panel');
            const list = document.getElementById('followup-list');
            if (!panel || !list) return;
            list.innerHTML = '';
            const items = Array.isArray(followUps) ? followUps.filter(Boolean).map(f => String(f).trim()).filter(Boolean).slice(0, 2) : [];
            if (!items.length){
                panel.classList.add('hidden');
                return;
            }
            for (const q of items){
                const li = document.createElement('li');
                li.textContent = q;
                list.appendChild(li);
            }
            panel.classList.remove('hidden');
        }

        function renderRelatedTopics(topics){
            const panel = document.getElementById('related-topics-panel');
            const list = document.getElementById('related-topics-list');
            if (!panel || !list) return;
            list.innerHTML = '';
            const items = Array.isArray(topics) ? topics.filter(Boolean).slice(0, 3) : [];
            if (!items.length){
                panel.classList.add('hidden');
                return;
            }
            items.forEach(t => {
                const item = document.createElement('div');
                item.className = 'related-topic-item';
                const title = document.createElement('div');
                title.className = 'related-topic-title';
                title.textContent = t.title || '';
                const desc = document.createElement('div');
                desc.className = 'related-topic-desc';
                desc.textContent = t.description || '';
                item.appendChild(title);
                if (desc.textContent) item.appendChild(desc);
                list.appendChild(item);
            });
            panel.classList.remove('hidden');
        }

        async function refreshRelatedSuggestions(prompt){
            const trimmed = (prompt || '').trim();
            const requestToken = ++relatedFetchToken;
            if (!trimmed){
                relatedTopicsState.topics = [];
                relatedTopicsState.followUps = [];
                relatedTopicsState.source = 'none';
                renderRelatedTopics([]);
                renderFollowupExamples([]);
                return;
            }
            try {
                const res = await fetch('/related_topics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: trimmed })
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (requestToken !== relatedFetchToken) return;
                relatedTopicsState.topics = Array.isArray(data.topics) ? data.topics : [];
                relatedTopicsState.followUps = Array.isArray(data.followUps) ? data.followUps : [];
                relatedTopicsState.source = data.source || 'unknown';
                if (!relatedTopicsState.topics.length){
                    relatedTopicsState.topics = keywordTopicFallback(trimmed);
                }
                renderRelatedTopics(relatedTopicsState.topics);
                renderFollowupExamples(relatedTopicsState.followUps);
            } catch (err) {
                console.error('Failed to fetch related topics', err);
                if (requestToken !== relatedFetchToken) return;
                relatedTopicsState.topics = keywordTopicFallback(trimmed);
                relatedTopicsState.followUps = [];
                relatedTopicsState.source = 'fallback-client';
                renderRelatedTopics(relatedTopicsState.topics);
                renderFollowupExamples([]);
            }
        }

        // Draggable resizer
        const resizer = document.getElementById('resizer');
        const leftPanel = document.querySelector('.left-panel');
        const rightPanel = document.querySelector('.right-panel');

        const resize = (e) => {
            const isHorizontal = window.innerWidth > 768;
            if (isHorizontal) {
                const newWidth = e.clientX;
                if (newWidth > 200 && newWidth < window.innerWidth - 200) {
                    leftPanel.style.flexBasis = `${newWidth}px`;
                }
            } else {
                const newHeight = e.clientY;
                if (newHeight > 100 && newHeight < window.innerHeight - 100) {
                    leftPanel.style.flexBasis = `${newHeight}px`;
                    leftPanel.style.height = `${newHeight}px`;
                }
            }
        };

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', resize);
            });
        });
</script>
</body>
</html>