<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    
</head>
<body>
    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner"><strong>Your voice will be recorded for training purposes.</strong></div>
    <!-- Start Screen -->
    <section id="start-screen">
        <div class="top-bar" style="padding: 12px 16px;">
            <div></div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">🌙</button>
        </div>
        <div class="center-hero">
            <div>
                <div class="hero-title">Hello</div>
                <div id="start-tool-grid" class="tool-grid"></div>
                <div id="start-sample-prompt" class="sample-prompt-text subtle" style="margin-top:12px; text-align:center;"></div>
            </div>
        </div>
        <div class="start-input-bar">
            <div class="start-input">
                <button id="start-upload-btn" class="icon-btn" title="Upload JSON">📄</button>
                <input id="start-query-input" placeholder="Ask a question or upload a JSON..." />
                <button id="start-mic-btn" class="icon-btn" title="Voice input">🎤</button>
                <button id="start-send-btn" class="send-btn">Send</button>
                <input id="start-file-input" type="file" accept=".json,.jsonl" class="hidden" />
            </div>
        </div>
    </section>

    <!-- Main App (two panels) -->
    <div class="main-container hidden" id="main-app">
        <div class="left-panel">
        <div class="top-bar">
            <div>
                <div class="title">Model Resources</div>
                <div class="subtle">See what functions and tools are being used</div>
            </div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">🌙</button>
        </div>
        <div id="json-meta"></div>
        <div id="entry-list-container" class="hidden">
            <div class="section-title">JSON Entries</div>
            <div id="entry-list"></div>
        </div>

    <div id="function-ideas-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Function Ideas</div>
        <div id="function-ideas-grid" class="function-ideas-grid"></div>
    </div>

    <div id="example-prompt-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Example Prompt</div>
        <div id="example-prompt-content" class="example-prompt-callout"></div>
    </div>

    <div id="suggested-tool-panel" class="hidden" style="margin-top: 8px;">
        <div class="section-title">Suggested Tool</div>
        <div id="suggested-tool-content" class="subtle"></div>
    </div>

    <div id="question-display" style="margin-top: auto;"></div>
    <div class="section-title inline-controls"><span>Tools</span></div>
    <div id="toolbox-view-left"></div>

    <div id="example-topics-panel" class="hidden" style="margin-top: 12px;">
        <div class="section-title">Example Topics</div>
        <div id="example-topics-list" class="example-topics-list"></div>
    </div>
    </div>

    <div id="resizer"></div>

    <div class="right-panel">
        <div class="form-container query-form-container">
            <h3>Query Interface</h3>
            <div id="query-conversation" class="query-conversation">
                </div>
            <form id="query-form" class="query-form">
                <input type="text" id="query-input" placeholder="Enter your query or use the mic...">
                <button type="button" id="mic-btn" class="mic-btn" title="Start/Stop voice">🎤</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <div class="form-container upload-form-container">
            <h3>Upload a JSON or JSONL file</h3>
            <form id="upload-form">
                <input type="file" name="file" id="file-input" accept=".json,.jsonl">
                <button type="submit" class="btn btn-primary">Upload</button>
            </form>
            <button id="save-chat-btn" class="btn" style="margin-top:10px;">Save Chat</button>
        </div>
    </div>
</div>

    <!-- Floating Tools button -->
    <button id="tools-fab" class="icon-btn" title="Tools & Raw JSON">🧰</button>

    <!-- Modal for Tools & Raw JSON -->
    <div id="tools-modal" class="modal-backdrop" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Tools & Raw JSON</div>
                <button id="tools-modal-close" class="icon-btn" aria-label="Close">✖</button>
            </div>
            <div class="section-title">Capabilities</div>
            <div class="tool-grid" style="margin-bottom:10px;">
                <div class="tool-card"><h4>Travel</h4><p>Flights, hotels, itineraries</p></div>
                <div class="tool-card"><h4>Science</h4><p>Facts, summaries, lookups</p></div>
                <div class="tool-card"><h4>Math</h4><p>Arithmetic, primes, series</p></div>
                <div class="tool-card"><h4>Trivia</h4><p>General knowledge Q&A</p></div>
            </div>
            <div class="section-title inline-controls">
                <span>Raw JSON</span>
                <button id="toggle-raw-btn" class="btn btn-ghost" style="padding: 4px 8px; font-size: 12px;">Show</button>
            </div>
            <pre id="json-content" class="hidden"></pre>
        </div>
    </div>
<script>
    // Theme handling
    (function initTheme(){
        const saved = localStorage.getItem('theme') || 'light';
        if (saved === 'dark') document.documentElement.setAttribute('data-theme','dark');
        const buttons = document.querySelectorAll('#theme-toggle');
        const setIcon = (btn) => { if (!btn) return; btn.textContent = document.documentElement.getAttribute('data-theme') === 'dark' ? '☀️' : '🌙'; };
        buttons.forEach(setIcon);
        document.addEventListener('click', (e)=>{
            if (e.target && e.target.id === 'theme-toggle'){
                const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = cur === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', next === 'dark' ? 'dark' : '');
                localStorage.setItem('theme', next);
                document.querySelectorAll('#theme-toggle').forEach(setIcon);
            }
        });
    })();

    // Track conversation log for saving later
    const conversationLog = [];
    let sessionStart = new Date().toISOString();
    let lastParsed = null;
    let allEntries = []; // Global store for unique entries
    let lastRawText = '';
    let functionIndex = []; // flattened functions with vectors for similarity
    let currentSamplePrompt = '';
    let lastUserQueryText = '';
    let topicIndex = []; // topics with vectors for inference

    // Modal handling and raw JSON toggler (modal)
    const toolsFab = document.getElementById('tools-fab');
    const toolsModal = document.getElementById('tools-modal');
    const toolsModalClose = document.getElementById('tools-modal-close');
    const rawPre = document.getElementById('json-content');
    const rawBtn = document.getElementById('toggle-raw-btn');
    toolsFab.addEventListener('click', ()=>{ toolsModal.classList.add('show'); });
    toolsModalClose.addEventListener('click', ()=>{ toolsModal.classList.remove('show'); });
    toolsModal.addEventListener('click', (e)=>{ if (e.target === toolsModal) toolsModal.classList.remove('show'); });
    rawBtn.addEventListener('click', ()=>{
        const hidden = rawPre.classList.toggle('hidden');
        rawBtn.textContent = hidden ? 'Show' : 'Hide';
    });

    // Transition from start screen to main app
    const startScreen = document.getElementById('start-screen');
    const mainApp = document.getElementById('main-app');
    function transitionToMain(){
        if (mainApp.classList.contains('hidden')){
            startScreen.classList.add('fade-out');
            setTimeout(()=>{ startScreen.style.display = 'none'; mainApp.classList.remove('hidden'); }, 200);
        }
    }
    // --- Start screen topics and sample prompt ---
    const ALL_TOPICS = [
        { title: 'Travel', desc: 'Flights, hotels, itineraries' },
        { title: 'Science', desc: 'Facts, summaries, lookups' },
        { title: 'Math', desc: 'Arithmetic, primes, series' },
        { title: 'Trivia', desc: 'General knowledge Q&A' },
        { title: 'Shopping', desc: 'Compare prices, find deals' },
        { title: 'Coding', desc: 'APIs, debugging, snippets' },
        { title: 'Health', desc: 'Wellness info, nutrition' },
        { title: 'Finance', desc: 'Budgets, markets, taxes' },
        { title: 'News', desc: 'Headlines, summaries' },
        { title: 'Education', desc: 'Study help, quizzes' },
        { title: 'Sports', desc: 'Scores, schedules, stats' },
        { title: 'Weather', desc: 'Forecasts and advisories' }
    ];
    const SAMPLE_PROMPTS = [
        'Find flights from SFO to NYC next Tuesday under $300 and a 2-night hotel near Times Square.',
        'Summarize the key differences between mitosis and meiosis with examples.',
        'Write a function to compute the nth Fibonacci number and show the first 10.',
        'What is the capital of Brazil and two facts about it?',
        'Compare the MacBook Air M2 vs. Dell XPS 13 for programming and battery life.'
    ];
    function pickRandom(arr, n){
        const a = arr.slice();
        for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
        return a.slice(0, n);
    }
    function renderStartTopics(){
        const grid = document.getElementById('start-tool-grid');
        if (!grid) return;
        grid.innerHTML = '';
        pickRandom(ALL_TOPICS, 4).forEach(t => {
            const card = document.createElement('div');
            card.className = 'tool-card';
            const h4 = document.createElement('h4'); h4.textContent = t.title;
            const p = document.createElement('p'); p.textContent = t.desc;
            card.appendChild(h4); card.appendChild(p);
            grid.appendChild(card);
        });
        currentSamplePrompt = pickRandom(SAMPLE_PROMPTS, 1)[0] || '';
        const sampleEl = document.getElementById('start-sample-prompt');
        if (sampleEl) sampleEl.textContent = currentSamplePrompt ? `Try: “${currentSamplePrompt}”` : '';
    }
    // Render at load
    renderStartTopics();
        // Load example topics JSON
        fetch('{{ url_for('static', filename='data/example_functions.json') }}')
            .then(r=>r.json())
            .then(data=>{ if (data && data.topics) { buildTopicIndex(data.topics); renderExampleTopics(data.topics); } })
            .catch(()=>{});
    // Start screen controls (send, mic, upload)
    const startQueryInput = document.getElementById('start-query-input');
    const startSendBtn = document.getElementById('start-send-btn');
    const startMicBtn = document.getElementById('start-mic-btn');
    const startUploadBtn = document.getElementById('start-upload-btn');
    const startFileInput = document.getElementById('start-file-input');

    startSendBtn?.addEventListener('click', ()=>{
        const q = (startQueryInput.value || '').trim(); if (!q) return;
        transitionToMain();
        document.getElementById('query-input').value = q;
        document.querySelector('#query-form button[type="submit"]').click();
        // Show example prompt on left after sending
        ensureExamplePromptRendered();
    });
    
    // Add Enter key support for start screen
    startQueryInput?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const q = (startQueryInput.value || '').trim(); if (!q) return;
            transitionToMain();
            document.getElementById('query-input').value = q;
            document.querySelector('#query-form button[type="submit"]').click();
            ensureExamplePromptRendered();
        }
    });
    startUploadBtn?.addEventListener('click', ()=> startFileInput.click());
    startFileInput?.addEventListener('change', function(){
        const file = this.files && this.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(ev){ lastRawText = ev.target.result || ''; rawPre.textContent = lastRawText; };
        reader.readAsText(file);
        const fd = new FormData(); fd.append('file', file);
        fetch('/upload_json', { method: 'POST', body: fd })
          .then(r=>r.json()).then(data=>{
            if (data.error) return alert('JSON parse error: ' + data.error);
            const entries = data.parsed_list || (data.parsed ? [data.parsed] : []);
            if (!entries.length) return;
            entries.forEach(newEntry => {
                if (newEntry.id && !allEntries.some(existing => existing.id === newEntry.id)) {
                    allEntries.push(newEntry);
                }
            });
            renderEntryList();
            renderToolboxView();
            transitionToMain();
            // Auto-submit first entry
            const first = allEntries[0];
            if (first && first.questionText){
                document.getElementById('query-input').value = first.questionText;
                document.querySelector('#query-form button[type="submit"]').click();
                renderEntry(first);
                ensureExamplePromptRendered();
            }
          }).catch(err=> alert('Error during backend JSON upload: ' + err));
    });

    // Start screen Deepgram streaming functions
    let startSocket, startMicrophone, startProcessor;
    let startHasFinalTranscript = false;
    let startVoiceMetadata = {
        words: [],
        utterances: [],
        session_start: new Date().toISOString(),
        total_duration: 0.0
    };
    
    async function startScreenDeepgramStreaming() {
        isRecording = true;
        startHasFinalTranscript = false;
        // Reset voice metadata
        startVoiceMetadata = {
            words: [],
            utterances: [],
            session_start: new Date().toISOString(),
            total_duration: 0.0
        };
        startMicBtn.classList.add('recording');
        startQueryInput.placeholder = "🎤 Listening... Speak now!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            startMicrophone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            startSocket = new WebSocket(wsUrl);

            startSocket.onopen = async () => {
                console.log('Start screen WebSocket connected for Deepgram streaming.');
                try {
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/ogg;codecs=opus';
                    
                    const mediaRecorder = new MediaRecorder(startMicrophone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && startSocket.readyState === WebSocket.OPEN) {
                            startSocket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.start(250);
                    startProcessor = mediaRecorder;
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    startSocket.close();
                }
            };

            startSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Capture utterance end events
                    if (data.type === 'UtteranceEnd') {
                        startVoiceMetadata.utterances.push({
                            type: 'utterance_end',
                            timestamp: new Date().toISOString()
                        });
                        console.log('[Start screen] Utterance ended');
                    }
                    
                    if (data.transcript) {
                        startQueryInput.value = data.transcript;
                        console.log('[Start screen] Transcript:', data.transcript, 'Final:', !data.interim);
                        
                        // Extract word-level metadata from backend message
                        if (!data.interim && data.words && Array.isArray(data.words)) {
                            console.log('[Start screen] Got word timestamps:', data.words);
                            for (const word of data.words) {
                                startVoiceMetadata.words.push({
                                    word: word.word || '',
                                    start: word.start || 0.0,
                                    end: word.end || 0.0,
                                    confidence: word.confidence || 0.0,
                                    punctuated_word: word.punctuated_word || word.word || ''
                                });
                                if (word.end > startVoiceMetadata.total_duration) {
                                    startVoiceMetadata.total_duration = word.end;
                                }
                            }
                        }
                        
                        if (data.interim) {
                            startQueryInput.style.fontStyle = 'italic';
                            startQueryInput.style.opacity = '0.8';
                        } else {
                            startQueryInput.style.fontStyle = 'normal';
                            startQueryInput.style.opacity = '1';
                            startHasFinalTranscript = true;
                            
                            // Auto-submit on final transcript - don't wait for user to click mic again
                            console.log('[Start screen] Got final transcript, auto-submitting...');
                            setTimeout(() => {
                                stopStartScreenDeepgramStreaming();
                            }, 500);
                        }
                    } else if (data.llm_response) {
                        // Ignore LLM interjections on start screen
                        console.log('[Start screen] Ignoring LLM interjection:', data.llm_response);
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            startSocket.onclose = (event) => {
                console.log('Start screen WebSocket closed:', event.code, event.reason);
            };
            
            startSocket.onerror = (err) => {
                console.error('Start screen WebSocket error:', err);
                if (isRecording) {
                    stopStartScreenDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Start screen mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopStartScreenDeepgramStreaming();
        }
    }

    async function stopStartScreenDeepgramStreaming() {
        console.log('[Start screen] Stopping, has final transcript:', startHasFinalTranscript, 'Input value:', startQueryInput.value);
        console.log('[Start screen] Voice metadata collected:', startVoiceMetadata);
        
        // Stop audio first
        if (startProcessor && startProcessor.stop) startProcessor.stop();
        if (startMicrophone) startMicrophone.getTracks().forEach(track => track.stop());
        isRecording = false;
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing...";
        startQueryInput.style.fontStyle = 'normal';
        startQueryInput.style.opacity = '1';
        
        // Wait longer for final transcript to arrive from WebSocket before closing it
        setTimeout(() => {
            if (startSocket) startSocket.close();
            startSocket = startMicrophone = startProcessor = null;
            
            // Auto-submit if we have text
            const text = startQueryInput.value.trim();
            console.log('[Start screen] Ready to submit, text:', text);
            
            // Save voice metadata to backend
            if (text && startVoiceMetadata.words.length > 0) {
                console.log('[Start screen] Saving voice metadata...');
                fetch('/save_voice_metadata', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        transcript: text,
                        metadata: startVoiceMetadata
                    })
                }).then(r => r.json())
                  .then(d => console.log('[Start screen] Voice metadata saved:', d))
                  .catch(err => console.error('[Start screen] Failed to save metadata:', err));
            }
            
            if (text) {
                startQueryInput.placeholder = "Submitting...";
                startSendBtn.click();
            } else {
                startQueryInput.placeholder = "Ask a question or upload a JSON...";
            }
        }, 800);
    }
    
    // Start screen chunked recording functions
    async function startScreenChunkedRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json(); 
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid; 
            isRecording = true; 
            startMicBtn.classList.add('recording');
            startQueryInput.placeholder = "Recording... Click mic to stop.";
            
            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch {}
                }
            });
            mediaRecorder.start(2000);
        } catch (err) { 
            alert('Unable to access microphone: ' + err.message); 
        }
    }
    
    async function stopStartScreenChunkedRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false; 
        mediaRecorder.stop(); 
        mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing transcription...";
        
        try { 
            const res2 = await fetch('/stt/stop', { method: 'POST' }); 
            const data = await res2.json(); 
            if (data.text) { 
                startQueryInput.value = data.text;
                // Auto-submit after transcription completes
                startSendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (err) {
            console.error('Failed to stop STT session:', err);
            alert('An error occurred while finalizing transcription.');
        } finally {
            startQueryInput.placeholder = "Ask a question or upload a JSON...";
            mediaRecorder = null;
            sttSid = null;
        }
    }
    
    // Start screen mic button - checks backend and routes appropriately
    startMicBtn?.addEventListener('click', async ()=>{
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopStartScreenDeepgramStreaming(); 
            else await startScreenDeepgramStreaming();
        } else {
            if (isRecording) await stopStartScreenChunkedRecording(); 
            else await startScreenChunkedRecording();
        }
    });
    // --- Voice Input: Conditional logic for STT backend ---
    const sttBackend = '{{ stt_backend }}';
    const micBtn = document.getElementById('mic-btn');
    const queryInput = document.getElementById('query-input');
    const sendBtn = document.querySelector('#query-form button[type="submit"]');

    let isRecording = false;

    // --- Logic for Deepgram Streaming STT ---
    let socket;
    let microphone;
    let processor;

    async function startDeepgramStreaming() {
        isRecording = true;
        micBtn.classList.add('recording');
        queryInput.placeholder = "🎤 Starting real-time conversation... Speak naturally!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            socket = new WebSocket(wsUrl);

            socket.onopen = async () => {
                console.log('WebSocket connected for Deepgram streaming.');
                try {
                    // Use MediaRecorder with a more compatible format
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/ogg;codecs=opus';
                    }
                    
                    const mediaRecorder = new MediaRecorder(microphone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
                            console.log('Sending audio chunk, size:', event.data.size);
                            socket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                    };
                    
                    mediaRecorder.start(250); // Send chunks every 250ms for better stability and less load
                    processor = mediaRecorder; // Store reference for cleanup
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    socket.close();
                }
            };

            socket.onmessage = (event) => {
                console.log('Received WebSocket message:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.transcript) {
                        // Real-time transcript updates
                        queryInput.value = data.transcript;
                        
                        // Visual feedback for interim vs final results
                        if (data.interim) {
                            queryInput.style.fontStyle = 'italic';
                            queryInput.style.opacity = '0.8';
                        } else {
                            queryInput.style.fontStyle = 'normal';
                            queryInput.style.opacity = '1';
                            // Don't add user message here - wait for LLM response
                        }
                        
                        console.log('Real-time transcript:', data.transcript, data.interim ? '(interim)' : '(final)');
                        
                    } else if (data.llm_response) {
                        // LLM interjected with a response
                        console.log('LLM interjection:', data.llm_response);
                        
                        const conversation = document.getElementById('query-conversation');
                        
                        // First add the user message (the complete transcript that triggered the response)
                        if (queryInput.value.trim()) {
                            const userMessage = document.createElement('div');
                            userMessage.className = 'message-user';
                            userMessage.textContent = queryInput.value.trim();
                            conversation.appendChild(userMessage);
                        }
                        
                        // Then add LLM response
                        const botMessage = document.createElement('div');
                        botMessage.className = 'message-bot';
                        botMessage.textContent = data.llm_response;
                        conversation.appendChild(botMessage);
                        conversation.scrollTop = conversation.scrollHeight;
                        
                        // Clear the input to continue listening for new speech
                        queryInput.value = '';
                        queryInput.placeholder = '🎤 Continue speaking... AI is listening';
                        
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                        queryInput.placeholder = '🎤 Real-time conversation active - speak naturally!';
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            socket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                if (isRecording) {
                    console.log('WebSocket closed unexpectedly during recording');
                    // Don't auto-reconnect, let user restart manually
                }
            };
            socket.onerror = (err) => {
                console.error('WebSocket error:', err);
                if (isRecording) {
                    console.log('WebSocket error during recording, stopping...');
                    stopDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopDeepgramStreaming(); // Cleanup on error
        }
    }

    async function stopDeepgramStreaming() {
        if (socket) socket.close();
        if (processor && processor.stop) processor.stop(); // Stop MediaRecorder
        if (microphone) microphone.getTracks().forEach(track => track.stop());
        isRecording = false;
        micBtn.classList.remove('recording');
        queryInput.placeholder = "Enter your query or use the mic...";
        
        // End the conversation session
        console.log('Ending real-time conversation session');
        queryInput.placeholder = "Real-time conversation ended. Click mic to start again.";
        
        socket = microphone = processor = null;
    }

    // --- Logic for chunked recording (Whisper/Gemini) ---
    let mediaRecorder = null;
    let sttSid = null;

    function chooseAudioMime() {
        const options = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'];
        for (const t of options) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
        }
        return '';
    }

    function extForMime(m) {
        if (!m) return 'webm';
        if (m.includes('ogg')) return 'ogg';
        return 'webm';
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json();
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid;
            if (sendBtn) sendBtn.disabled = true;

            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch (err) { console.error('Chunk upload failed', err); }
                }
            });

            mediaRecorder.start(2000);
            isRecording = true;
            micBtn.classList.add('recording');
            queryInput.placeholder = "Recording... Click mic to stop.";
        } catch (err) {
            console.error('Mic error:', err);
            alert('Unable to access microphone: ' + err.message);
        }
    }

    async function stopRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        micBtn.classList.remove('recording');
        if (sendBtn) sendBtn.disabled = false;
        queryInput.placeholder = "Finalizing transcription...";

        try {
            const res = await fetch('/stt/stop', { method: 'POST' });
            const data = await res.json();
            if (data.text) {
                queryInput.value = data.text;
                sendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (e) {
            console.error('Failed to stop STT session:', e);
            alert('An error occurred while finalizing transcription.');
        } finally {
            queryInput.placeholder = "Enter your query or use the mic...";
            mediaRecorder = null;
            sttSid = null;
        }
    }

    // Main mic button event listener
    micBtn?.addEventListener('click', async () => {
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopDeepgramStreaming(); else await startDeepgramStreaming();
        } else {
            if (isRecording) await stopRecording(); else await startRecording();
        }
    });

 
    document.getElementById('upload-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select a file.");
                return;
            }

            //display raw json (modal)
            const reader = new FileReader();
            reader.onload = function(event) {
                const rawText = event.target.result; lastRawText = rawText || '';
                rawPre.textContent = rawText;
            };
            reader.onerror = function(event) {
                alert("Error reading: " + event.target.error.name);
            };
            reader.readAsText(file);

            //send to backend for JSON parsing and UI hydration
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_json', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('JSON parse error:', data.error);
                    alert('JSON parse error: ' + data.error);
                    return;
                }
                console.log(data.message);
                const entries = data.parsed_list || (data.parsed ? [data.parsed] : []);
                if (!entries.length) return;

                // Merge new entries, ensuring no duplicates based on ID
                let newEntriesAdded = false;
                entries.forEach(newEntry => {
                    if (newEntry.id && !allEntries.some(existing => existing.id === newEntry.id)) {
                        allEntries.push(newEntry);
                        newEntriesAdded = true;
                    }
                });

                renderEntryList();
                renderToolboxView(); // Render tools to the left panel

                // If this is the first upload or new entries were added,
                // render the details of the first overall entry.
                if (allEntries.length > 0 && newEntriesAdded) {
                    renderEntry(allEntries[0]);
                    // Highlight the first entry button as active
                    const firstBtn = document.querySelector('.entry-btn');
                    if(firstBtn) firstBtn.classList.add('active');
                    ensureExamplePromptRendered();
                }
            })
            .catch(error => {
                console.error('Error during backend JSON upload:', error);
            });
        });

        document.getElementById('query-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const queryInput = document.getElementById('query-input');
            const query = queryInput.value.trim();
            if (!query) return;
            lastUserQueryText = query;

            // Display user message
            const conversation = document.getElementById('query-conversation');
            const userMessage = document.createElement('div');
            userMessage.className = 'message-user';
            userMessage.textContent = query;
            conversation.appendChild(userMessage);
            conversation.scrollTop = conversation.scrollHeight;

            // Log turn
            conversationLog.push({
                turn: conversationLog.length + 1,
                role: 'user',
                inputType: 'text',
                content: query,
                timestamp: new Date().toISOString()
            });

            // Clear input
            queryInput.value = '';

            // Update example prompt and suggested tool
            ensureExamplePromptRendered();
            showSuggestedTool(lastUserQueryText);
            inferAndHighlightTopic(lastUserQueryText);

            //send query to backend
            const queryData = new FormData();
            queryData.append('query', query);

            fetch ('/query', {
                method: 'POST',
                body: queryData
            })
            .then(response => response.json())
            .then(data => {
                // Display bot response
                const botMessage = document.createElement('div');
                botMessage.className = 'message-bot';
                botMessage.textContent = data.response || (data.error ? ('Error: ' + data.error) : '');
                conversation.appendChild(botMessage);
                conversation.scrollTop = conversation.scrollHeight;

                // Log bot turn
                conversationLog.push({
                    turn: conversationLog.length + 1,
                    role: 'assistant',
                    inputType: 'model',
                    content: botMessage.textContent,
                    timestamp: new Date().toISOString()
                });
            })
            .catch(error => {
                console.error('Error during backend query:', error);
            });
        });

        // Save chat button handler
        function renderEntryList() {
            const entryListContainer = document.getElementById('entry-list-container');
            const entryList = document.getElementById('entry-list');
            entryList.innerHTML = '';

            if (allEntries.length > 1) {
                entryListContainer.classList.remove('hidden');
            } else {
                entryListContainer.classList.add('hidden');
            }

            allEntries.forEach((entry, index) => {
                const wrapper = document.createElement('div');
                wrapper.className = 'entry-item-wrapper';

                const btn = document.createElement('button');
                btn.textContent = entry.id || `Entry ${index + 1}`;
                btn.className = 'btn entry-btn';
                btn.dataset.entryId = entry.id;
                btn.addEventListener('click', () => {
                    renderEntry(entry);
                    document.querySelectorAll('.entry-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                });

                const removeBtn = document.createElement('button');
                removeBtn.textContent = '×';
                removeBtn.className = 'btn-remove-entry';
                removeBtn.title = 'Remove entry';
                removeBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); // Prevent the main button click
                    allEntries = allEntries.filter(e => e.id !== entry.id);
                    renderEntryList();
                    renderToolboxView(); // Re-render tools in left panel
                    // Optional: Clear the view if the active entry was removed
                    if (lastParsed && lastParsed.id === entry.id) {
                        document.getElementById('json-meta').innerHTML = '';
                        document.getElementById('question-display').innerHTML = '';
                        rawPre.textContent = '';
                        lastParsed = null;
                    }
                });

                wrapper.appendChild(btn);
                wrapper.appendChild(removeBtn);
                entryList.appendChild(wrapper);
            });
        }

        document.getElementById('save-chat-btn').addEventListener('click', function() {
            const payload = {
                sessionInfo: {
                    sessionId: crypto.randomUUID(),
                    userId: 'anonymous',
                    startTimestamp: sessionStart,
                    endTimestamp: new Date().toISOString(),
                    llmModel: 'gemini-1.5-flash-latest'
                },
                context: {
                    initialContent: lastParsed?.questionText || '',
                    finalContent: conversationLog.length ? conversationLog[conversationLog.length - 1].content : ''
                },
                conversationLog: conversationLog,
                evaluation: {
                    surveyResponses: {},
                    userComments: ''
                }
            };
            fetch('/save_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(d => {
                if (d.error) {
                    alert('Failed to save: ' + d.error);
                } else {
                    alert('Saved: ' + d.dirName);
                }
            })
            .catch(err => {
                alert('Save error: ' + err);
            });
        });

        function renderEntry(entry) {
            lastParsed = entry;

            // Clear previous meta content
            document.getElementById('json-meta').innerHTML = '';

            // Populate the new question display area at the bottom
            const questionDiv = document.getElementById('question-display');
            questionDiv.innerHTML = ''; // Clear previous question
            const qP = document.createElement('p');
            qP.innerHTML = `<strong>Question:</strong><br>${entry.questionText || ''}`;
            questionDiv.appendChild(qP);

            const submitBtn = document.createElement('button');
            submitBtn.textContent = 'Submit Question to Chat';
            submitBtn.className = 'btn submit-question-btn';
            submitBtn.addEventListener('click', () => {
                const q = (entry.questionText || '').trim();
                if (q) {
                    document.getElementById('query-input').value = q;
                    document.querySelector('#query-form button[type="submit"]').click();
                }
            });
            questionDiv.appendChild(submitBtn);

            // Update raw JSON view in modal if raw present
            if (entry.raw) { rawPre.textContent = JSON.stringify(entry.raw, null, 2); }
            // The toolbox is now global and does not need to be re-rendered on entry selection.
        }

        function renderToolboxView(){
            const functions = [];
            allEntries.forEach(entry => {
                (entry.functions || []).forEach(func => {
                    functions.push({ ...func, entryId: entry.id });
                });
            });

            // Build function index with vectors for similarity
            functionIndex = functions.map(fn => {
                const full = (fn.name || '').trim();
                let toolbox = 'misc';
                let tool = full || '(unnamed)';
                if (full.includes('.')){
                    const idx = full.indexOf('.');
                    toolbox = full.slice(0, idx) || 'misc';
                    tool = full.slice(idx+1) || '(unnamed)';
                }
                const paramNames = [];
                try {
                    const params = fn.parameters || {};
                    if (params && params.properties) {
                        for (const k of Object.keys(params.properties)) paramNames.push(k);
                    }
                } catch {}
                const text = [full, fn.description || '', paramNames.join(' ')].join(' ').toLowerCase();
                return {
                    fullName: full,
                    toolbox,
                    tool,
                    desc: fn.description || '',
                    params: fn.parameters,
                    entryId: fn.entryId,
                    triVector: trigramVector(text),
                    wordVector: wordVector(text),
                    tokens: new Set(text.split(/[^a-z0-9]+/).filter(Boolean))
                };
            });

            const container = document.getElementById('toolbox-view-left');
            container.innerHTML = '';
            if (!functions || !functions.length){
                const p = document.createElement('p'); p.className = 'subtle'; p.textContent = 'No tools found in JSON.'; container.appendChild(p); return;
            }
            const groups = {};
            for (const fi of functionIndex){
                if (!groups[fi.toolbox]) groups[fi.toolbox] = [];
                groups[fi.toolbox].push({ tool: fi.tool, desc: fi.desc, params: fi.params, entryId: fi.entryId });
            }

            const toolboxNames = Object.keys(groups).sort((a,b)=>a.localeCompare(b));
            for (const name of toolboxNames){
                const items = groups[name];
                const details = document.createElement('details');
                details.className = 'toolbox';
                const summary = document.createElement('summary');
                summary.innerHTML = `${name} <span class="badge">${items.length}</span>`;
                details.appendChild(summary);
                const ul = document.createElement('ul');
                ul.className = 'tool-list';
                for (const it of items){
                    const li = document.createElement('li');
                    const d = document.createElement('details'); d.className = 'tool';
                    const s = document.createElement('summary'); 
                    s.textContent = it.tool;

                    const entryIdSpan = document.createElement('span');
                    entryIdSpan.className = 'tool-entry-id';
                    entryIdSpan.textContent = it.entryId || '';
                    s.appendChild(entryIdSpan);

                    d.appendChild(s);
                    if (it.desc){ const desc = document.createElement('div'); desc.className = 'tool-desc'; desc.textContent = it.desc; d.appendChild(desc); }
                    if (it.params){ const pre = document.createElement('pre'); pre.className = 'tool-params'; pre.textContent = JSON.stringify(it.params, null, 2); d.appendChild(pre); }
                    li.appendChild(d);
                    ul.appendChild(li);
                }
                details.appendChild(ul);
                container.appendChild(details);
            }

            // If we already have a last query, update the suggestion
            if (lastUserQueryText) showSuggestedTool(lastUserQueryText);
            if (lastUserQueryText) inferAndHighlightTopic(lastUserQueryText);

            // Render function ideas
            renderFunctionIdeas();
        }

        // --- Similarity helpers (trigram + cosine) ---
        function trigramVector(text){
            const v = new Map();
            const t = (text || '').toLowerCase();
            for (let i=0;i<t.length-2;i++){
                const tri = t.slice(i,i+3);
                v.set(tri, (v.get(tri)||0)+1);
            }
            return v;
        }
        function wordVector(text){
            const v = new Map();
            const tokens = (text||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
            for (const tok of tokens){ v.set(tok, (v.get(tok)||0)+1); }
            return v;
        }
        function cosineSim(v1, v2){
            if (!v1 || !v2) return 0;
            let dot=0, norm1=0, norm2=0;
            for (const [,w] of v1) norm1 += w*w;
            for (const [,w] of v2) norm2 += w*w;
            const smaller = v1.size < v2.size ? v1 : v2;
            const other = smaller===v1 ? v2 : v1;
            for (const [k,w] of smaller){ const w2 = other.get(k)||0; if (w2) dot += w*w2; }
            if (!norm1 || !norm2) return 0;
            return dot / (Math.sqrt(norm1)*Math.sqrt(norm2));
        }
        function showSuggestedTool(queryText){
            const panel = document.getElementById('suggested-tool-panel');
            const content = document.getElementById('suggested-tool-content');
            if (!functionIndex.length){ content.textContent = 'No tools loaded yet.'; panel.classList.remove('hidden'); return; }

            const q = (queryText||'').toLowerCase();
            const qTri = trigramVector(q);
            const qWord = wordVector(q);
            const qTokens = new Set(q.split(/[^a-z0-9]+/).filter(Boolean));
            let best = null, bestScore = -1, bestParts = {tri:0, word:0, boost:0};
            for (const fi of functionIndex){
                const sTri = cosineSim(qTri, fi.triVector);
                const sWord = cosineSim(qWord, fi.wordVector);
                // Boost for shared tokens in toolbox/tool name
                let boost = 0;
                for (const tok of qTokens){
                    if (fi.tokens.has(tok)) boost += 0.02; // small incremental boost
                    if (tok === fi.toolbox || tok === fi.tool) boost += 0.05;
                }
                const s = 0.7*sTri + 0.3*sWord + boost;
                if (s > bestScore){ bestScore = s; best = fi; bestParts = {tri:sTri, word:sWord, boost}; }
            }
            if (!best){ content.textContent = 'No suggestion available.'; panel.classList.remove('hidden'); return; }
            const pct = Math.max(0, Math.min(1, bestScore))*100;
            content.innerHTML = `<strong>${best.toolbox}.${best.tool}</strong>${best.desc?` — ${best.desc}`:''}<br><span class="subtle">Match: ${pct.toFixed(1)}% (tri:${(bestParts.tri*100).toFixed(0)}% word:${(bestParts.word*100).toFixed(0)}%)</span>`;
            panel.classList.remove('hidden');
        }

        function ensureExamplePromptRendered(){
            const p = document.getElementById('example-prompt-panel');
            const c = document.getElementById('example-prompt-content');
            if (!currentSamplePrompt){ return; }
            c.textContent = currentSamplePrompt;
            p.classList.remove('hidden');
        }

        function renderFunctionIdeas(){
            const panel = document.getElementById('function-ideas-panel');
            const grid = document.getElementById('function-ideas-grid');
            if (!functionIndex.length){ panel.classList.add('hidden'); grid.innerHTML=''; return; }
            const n = Math.min(functionIndex.length, Math.floor(Math.random()*2)+4); // 4 or 5
            const picks = pickRandom(functionIndex, n);
            grid.innerHTML = '';
            for (const fi of picks){
                const card = document.createElement('div');
                card.className = 'function-idea-card';
                const title = document.createElement('div'); title.className = 'function-idea-title'; title.textContent = `${fi.toolbox}.${fi.tool}`;
                const desc = document.createElement('div'); desc.className = 'function-idea-desc'; desc.textContent = fi.desc || '';
                card.appendChild(title); card.appendChild(desc);
                grid.appendChild(card);
            }
            panel.classList.remove('hidden');
        }

        // --- Example Topics ---
        function buildTopicIndex(topics){
            topicIndex = topics.map(t => {
                const text = [t.title, t.description, ...(t.functions||[]).map(f=>`${f.name} ${f.description}`)].join(' ').toLowerCase();
                return { id: t.id, title: t.title, description: t.description, triVector: trigramVector(text), wordVector: wordVector(text) };
            });
        }
        function renderExampleTopics(topics){
            const panel = document.getElementById('example-topics-panel');
            const list = document.getElementById('example-topics-list');
            if (!topics || !topics.length){ panel.classList.add('hidden'); return; }
            list.innerHTML = '';
            for (const t of topics){
                const item = document.createElement('div');
                item.className = 'example-topic-item';
                const title = document.createElement('div'); title.className = 'example-topic-title'; title.textContent = t.title;
                const desc = document.createElement('div'); desc.className = 'example-topic-desc'; desc.textContent = t.description || '';
                item.dataset.topicId = t.id;
                item.appendChild(title); item.appendChild(desc);
                list.appendChild(item);
            }
            panel.classList.remove('hidden');
        }
        function inferAndHighlightTopic(query){
            const list = document.getElementById('example-topics-list');
            if (!list || !topicIndex.length) return;
            const q = (query||'').toLowerCase();
            const qTri = trigramVector(q);
            const qWord = wordVector(q);
            let bestId = null, bestScore = -1;
            for (const t of topicIndex){
                const s = 0.7*cosineSim(qTri, t.triVector) + 0.3*cosineSim(qWord, t.wordVector);
                if (s > bestScore){ bestScore = s; bestId = t.id; }
            }
            // Clear highlights
            list.querySelectorAll('.example-topic-item').forEach(el => el.classList.remove('active'));
            if (bestId){
                const el = list.querySelector(`.example-topic-item[data-topic-id="${bestId}"]`);
                if (el) el.classList.add('active');
            }
        }

        // Draggable resizer
        const resizer = document.getElementById('resizer');
        const leftPanel = document.querySelector('.left-panel');
        const rightPanel = document.querySelector('.right-panel');

        const resize = (e) => {
            const isHorizontal = window.innerWidth > 768;
            if (isHorizontal) {
                const newWidth = e.clientX;
                if (newWidth > 200 && newWidth < window.innerWidth - 200) {
                    leftPanel.style.flexBasis = `${newWidth}px`;
                }
            } else {
                const newHeight = e.clientY;
                if (newHeight > 100 && newHeight < window.innerHeight - 100) {
                    leftPanel.style.flexBasis = `${newHeight}px`;
                    leftPanel.style.height = `${newHeight}px`;
                }
            }
        };

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', resize);
            });
        });
</script>
</body>
</html>