<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    
</head>
<body>
    <!-- Disclaimer Banner -->
    <div class="disclaimer-banner"><strong>Your voice will be recorded for training purposes.</strong></div>
    <!-- Start Screen -->
    <section id="start-screen">
        <div class="top-bar" style="padding: 12px 16px;">
            <div></div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">ðŸŒ™</button>
        </div>
        <div class="center-hero">
            <div>
                <div class="hero-title">Welcome to Blanca</div>
                <div class="hero-tagline subtle">Please use the microphone to begin your prompt. Below are some of the possible topics you can ask and an example question.</div>
                <div class="start-examples">
                    <div class="start-topics-section">
                        <div class="start-section-title subtle">Suggested topics</div>
                        <div id="start-topics-grid" class="start-topics-grid"></div>
                    </div>
                    <div class="start-example-section">
                        <div class="start-section-title subtle">Example question</div>
                        <div id="start-sample-prompt" class="sample-prompt-text"></div>
                    </div>
                </div>
            </div>
        </div>
        <div class="start-input-bar">
            <div class="start-input">
                <input id="start-query-input" placeholder="Ask a question..." />
                <button id="start-mic-btn" class="icon-btn" title="Voice input">ðŸŽ¤</button>
                <button id="start-send-btn" class="send-btn">Send</button>
            </div>
        </div>
    </section>

    <!-- Main App (two panels) -->
    <div class="main-container hidden" id="main-app">
        <div class="left-panel">
            <div class="top-bar">
                <div class="lhs-intro">
                    <div class="title">Please continue your conversation using the microphone.</div>
                    <div class="subtle">Below are some related topics you can explore.</div>
                </div>
                <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">ðŸŒ™</button>
            </div>

            <div id="latest-prompt-panel" class="hidden" style="margin-top: 8px;">
                <div class="section-title">Your Prompt</div>
                <div id="latest-prompt-content" class="latest-prompt-callout"></div>
            </div>

            <div id="followup-panel" class="hidden" style="margin-top: 8px;">
                <div class="section-title">Suggested Follow-ups</div>
                <ul id="followup-list" class="followup-list"></ul>
            </div>

            <div id="related-topics-panel" class="hidden" style="margin-top: 12px;">
                <div class="section-title">Related Topics</div>
                <div id="related-topics-list" class="related-topics-list"></div>
            </div>
        </div>

    <div id="resizer"></div>

    <div class="right-panel">
        <div class="form-container query-form-container">
            <h3>Query Interface</h3>
            <div id="query-conversation" class="query-conversation">
                </div>
            <form id="query-form" class="query-form">
                <input type="text" id="query-input" placeholder="Enter your query or use the mic...">
                <button type="button" id="mic-btn" class="mic-btn" title="Start/Stop voice">ðŸŽ¤</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <button id="save-chat-btn" class="btn" style="margin-top:10px;">Save Chat</button>
    </div>
</div>

    <!-- Floating Tools button -->
    <!-- <button id="tools-fab" class="icon-btn" title="Tools & Raw JSON">ðŸ§°</button> -->

    <!-- Modal for Tools & Raw JSON -->
    <div id="tools-modal" class="modal-backdrop" aria-hidden="true">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-title">Tools & Raw JSON</div>
                <button id="tools-modal-close" class="icon-btn" aria-label="Close">âœ–</button>
            </div>
            <div class="section-title">Capabilities</div>
            <div class="tool-grid" style="margin-bottom:10px;">
                <div class="tool-card"><h4>Travel</h4><p>Flights, hotels, itineraries</p></div>
                <div class="tool-card"><h4>Science</h4><p>Facts, summaries, lookups</p></div>
                <div class="tool-card"><h4>Math</h4><p>Arithmetic, primes, series</p></div>
                <div class="tool-card"><h4>Trivia</h4><p>General knowledge Q&A</p></div>
            </div>
            <div class="section-title inline-controls">
                <span>Raw JSON</span>
                <button id="toggle-raw-btn" class="btn btn-ghost" style="padding: 4px 8px; font-size: 12px;">Show</button>
            </div>
            <pre id="json-content" class="hidden"></pre>
        </div>
    </div>
<script>
    // Theme handling
    (function initTheme(){
        const saved = localStorage.getItem('theme') || 'light';
        if (saved === 'dark') document.documentElement.setAttribute('data-theme','dark');
        const buttons = document.querySelectorAll('#theme-toggle');
        const setIcon = (btn) => { if (!btn) return; btn.textContent = document.documentElement.getAttribute('data-theme') === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™'; };
        buttons.forEach(setIcon);
        document.addEventListener('click', (e)=>{
            if (e.target && e.target.id === 'theme-toggle'){
                const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = cur === 'dark' ? 'light' : 'dark';
                document.documentElement.setAttribute('data-theme', next === 'dark' ? 'dark' : '');
                localStorage.setItem('theme', next);
                document.querySelectorAll('#theme-toggle').forEach(setIcon);
            }
        });
    })();

    // Track conversation log for saving later
    const conversationLog = [];
    let sessionStart = new Date().toISOString();
    let isRecording = false;
    let startSamplePrompt = '';
    let latestUserPrompt = '';
    let lastUserQueryText = '';
    const relatedTopicsState = { topics: [], followUps: [], source: 'none' };
    let keywordTopicIndex = [];
    let keywordTopicItems = [];
    let relatedFetchToken = 0;

    // Modal handling and raw JSON toggler (modal)
    const toolsFab = document.getElementById('tools-fab');
    const toolsModal = document.getElementById('tools-modal');
    const toolsModalClose = document.getElementById('tools-modal-close');
    const rawPre = document.getElementById('json-content');
    const rawBtn = document.getElementById('toggle-raw-btn');
    if (toolsFab && toolsModal && toolsModalClose) {
        toolsFab.addEventListener('click', ()=>{ toolsModal.classList.add('show'); });
        toolsModalClose.addEventListener('click', ()=>{ toolsModal.classList.remove('show'); });
        toolsModal.addEventListener('click', (e)=>{ if (e.target === toolsModal) toolsModal.classList.remove('show'); });
    }
    if (rawBtn && rawPre) {
        rawBtn.addEventListener('click', ()=>{
            const hidden = rawPre.classList.toggle('hidden');
            rawBtn.textContent = hidden ? 'Show' : 'Hide';
        });
    }

    // Transition from start screen to main app
    const startScreen = document.getElementById('start-screen');
    const mainApp = document.getElementById('main-app');
    function transitionToMain(){
        if (mainApp.classList.contains('hidden')){
            startScreen.classList.add('fade-out');
            setTimeout(()=>{ startScreen.style.display = 'none'; mainApp.classList.remove('hidden'); }, 200);
        }
    }
    // --- Start screen topics and sample prompt ---
    const ALL_TOPICS = [
        { title: 'Travel', desc: 'Flights, hotels, itineraries' },
        { title: 'Science', desc: 'Facts, summaries, lookups' },
        { title: 'Math', desc: 'Arithmetic, primes, series' },
        { title: 'Trivia', desc: 'General knowledge Q&A' },
        { title: 'Shopping', desc: 'Compare prices, find deals' },
        { title: 'Coding', desc: 'APIs, debugging, snippets' },
        { title: 'Health', desc: 'Wellness info, nutrition' },
        { title: 'Finance', desc: 'Budgets, markets, taxes' },
        { title: 'News', desc: 'Headlines, summaries' },
        { title: 'Education', desc: 'Study help, quizzes' },
        { title: 'Sports', desc: 'Scores, schedules, stats' },
        { title: 'Weather', desc: 'Forecasts and advisories' }
    ];
    const SAMPLE_PROMPTS = [
        'Find flights from SFO to NYC next Tuesday under $300 and a 2-night hotel near Times Square.',
        'Summarize the key differences between mitosis and meiosis with examples.',
        'Write a function to compute the nth Fibonacci number and show the first 10.',
        'What is the capital of Brazil and two facts about it?',
        'Compare the MacBook Air M2 vs. Dell XPS 13 for programming and battery life.'
    ];
    const TOPIC_SYNONYM_MAP = {
        physics: ['physics', 'mechanics', 'mechanic', 'quantum', 'gravity', 'force', 'forces', 'energy', 'motion', 'optics', 'electromagnetism', 'relativity', 'thermodynamics', 'waves'],
        search: ['search', 'lookup', 'google', 'bing', 'find', 'discover', 'locate', 'query', 'information', 'research'],
        trivia: ['trivia', 'facts', 'fact', 'quiz', 'questions', 'curiosity', 'knowledge'],
        math: ['math', 'mathematics', 'algebra', 'geometry', 'calculus', 'statistics', 'arithmetic', 'numbers', 'equations'],
        weather: ['weather', 'forecast', 'temperature', 'rain', 'climate', 'conditions', 'storm', 'humidity'],
        finance: ['finance', 'stocks', 'markets', 'budget', 'investing', 'investment', 'money', 'economy', 'economic'],
        coding: ['coding', 'programming', 'debug', 'debugging', 'code', 'software', 'api', 'development', 'compute'],
        travel: ['travel', 'trip', 'journey', 'flights', 'flight', 'hotel', 'vacation', 'itinerary', 'tourism'],
        health: ['health', 'wellness', 'nutrition', 'fitness', 'exercise', 'diet', 'medical', 'medicine'],
        sports: ['sports', 'game', 'games', 'scores', 'athletics', 'leagues', 'teams', 'tournament'],
        news: ['news', 'headlines', 'breaking', 'articles', 'media', 'press', 'reports', 'reporting'],
        education: ['education', 'study', 'learning', 'school', 'teaching', 'quiz', 'lesson', 'class']
    };
    function pickRandom(arr, n){
        const a = arr.slice();
        for (let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; }
        return a.slice(0, n);
    }
    function renderStartTopics(){
        const grid = document.getElementById('start-topics-grid');
        if (grid){
            grid.innerHTML = '';
            pickRandom(ALL_TOPICS, 4).forEach(t => {
                const card = document.createElement('div');
                card.className = 'start-topic-card';
                const title = document.createElement('div');
                title.className = 'start-topic-title';
                title.textContent = t.title;
                const desc = document.createElement('div');
                desc.className = 'start-topic-desc';
                desc.textContent = t.desc;
                card.appendChild(title);
                card.appendChild(desc);
                grid.appendChild(card);
            });
        }
        startSamplePrompt = pickRandom(SAMPLE_PROMPTS, 1)[0] || '';
        const sampleEl = document.getElementById('start-sample-prompt');
        if (sampleEl) sampleEl.textContent = startSamplePrompt ? `Try asking: â€œ${startSamplePrompt}â€` : '';
    }
    // Render at load
    renderStartTopics();
    fetch('{{ url_for('static', filename='data/example_functions.json') }}')
        .then(r=>r.json())
        .then(data => { if (data && Array.isArray(data.topics)) buildKeywordTopicIndex(data.topics); })
        .catch(err => console.warn('Failed to load topic catalog', err));
    // Start screen controls (send, mic)
    const startQueryInput = document.getElementById('start-query-input');
    const startSendBtn = document.getElementById('start-send-btn');
    const startMicBtn = document.getElementById('start-mic-btn');

    startSendBtn?.addEventListener('click', ()=>{
        const q = (startQueryInput.value || '').trim(); if (!q) return;
        transitionToMain();
        document.getElementById('query-input').value = q;
        updateLatestPromptPanel(q);
        refreshRelatedSuggestions(q);
        document.querySelector('#query-form button[type="submit"]').click();
        // Clear the start screen input to prevent caching
        startQueryInput.value = '';
        // Reset submission flag
        startIsSubmitting = false;
    });
    
    // Add Enter key support for start screen
    startQueryInput?.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            const q = (startQueryInput.value || '').trim(); if (!q) return;
            transitionToMain();
            document.getElementById('query-input').value = q;
            updateLatestPromptPanel(q);
            refreshRelatedSuggestions(q);
            document.querySelector('#query-form button[type="submit"]').click();
            // Clear the start screen input to prevent caching
            startQueryInput.value = '';
            // Reset submission flag
            startIsSubmitting = false;
        }
    });

    // Start screen Deepgram streaming functions
    let startSocket, startMicrophone, startProcessor;
    let startHasFinalTranscript = false;
    let startIsSubmitting = false; // Flag to prevent re-recording during submission
    let startVoiceMetadata = {
        words: [],
        utterances: [],
        session_start: new Date().toISOString(),
        total_duration: 0.0
    };
    
    async function startScreenDeepgramStreaming() {
        if (startIsSubmitting) return; // Prevent starting during submission
        isRecording = true;
        startHasFinalTranscript = false;
        startIsSubmitting = false;
        // Reset voice metadata
        startVoiceMetadata = {
            words: [],
            utterances: [],
            session_start: new Date().toISOString(),
            total_duration: 0.0
        };
        startMicBtn.classList.add('recording');
        startQueryInput.placeholder = "ðŸŽ¤ Listening... Speak now!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            startMicrophone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            startSocket = new WebSocket(wsUrl);

            startSocket.onopen = async () => {
                console.log('Start screen WebSocket connected for Deepgram streaming.');
                try {
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/webm';
                    if (!MediaRecorder.isTypeSupported(mimeType)) mimeType = 'audio/ogg;codecs=opus';
                    
                    const mediaRecorder = new MediaRecorder(startMicrophone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && startSocket.readyState === WebSocket.OPEN) {
                            startSocket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.start(250);
                    startProcessor = mediaRecorder;
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    startSocket.close();
                }
            };

            startSocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    
                    // Capture utterance end events
                    if (data.type === 'UtteranceEnd') {
                        startVoiceMetadata.utterances.push({
                            type: 'utterance_end',
                            timestamp: new Date().toISOString()
                        });
                        console.log('[Start screen] Utterance ended');
                    }
                    
                    if (data.transcript) {
                        startQueryInput.value = data.transcript;
                        console.log('[Start screen] Transcript:', data.transcript, 'Final:', !data.interim);
                        
                        // Extract word-level metadata from backend message
                        if (!data.interim && data.words && Array.isArray(data.words)) {
                            console.log('[Start screen] Got word timestamps:', data.words);
                            for (const word of data.words) {
                                startVoiceMetadata.words.push({
                                    word: word.word || '',
                                    start: word.start || 0.0,
                                    end: word.end || 0.0,
                                    confidence: word.confidence || 0.0,
                                    punctuated_word: word.punctuated_word || word.word || ''
                                });
                                if (word.end > startVoiceMetadata.total_duration) {
                                    startVoiceMetadata.total_duration = word.end;
                                }
                            }
                        }
                        
                        if (data.interim) {
                            startQueryInput.style.fontStyle = 'italic';
                            startQueryInput.style.opacity = '0.8';
                        } else {
                            startQueryInput.style.fontStyle = 'normal';
                            startQueryInput.style.opacity = '1';
                            startHasFinalTranscript = true;
                        }
                    } else if (data.llm_response) {
                        // Ignore LLM interjections on start screen
                        console.log('[Start screen] Ignoring LLM interjection:', data.llm_response);
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            startSocket.onclose = (event) => {
                console.log('Start screen WebSocket closed:', event.code, event.reason);
            };
            
            startSocket.onerror = (err) => {
                console.error('Start screen WebSocket error:', err);
                if (isRecording) {
                    stopStartScreenDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Start screen mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopStartScreenDeepgramStreaming();
        }
    }

    async function stopStartScreenDeepgramStreaming() {
        if (!isRecording) return; // Already stopped
        
        console.log('[Start screen] Stopping, has final transcript:', startHasFinalTranscript, 'Input value:', startQueryInput.value);
        console.log('[Start screen] Voice metadata collected:', startVoiceMetadata);
        
        // Stop audio immediately
        if (startProcessor && startProcessor.stop) startProcessor.stop();
        if (startMicrophone) startMicrophone.getTracks().forEach(track => track.stop());
        isRecording = false;
        startIsSubmitting = true; // Lock to prevent re-recording
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing...";
        startQueryInput.style.fontStyle = 'normal';
        startQueryInput.style.opacity = '1';
        
        // Brief wait for final transcript, then submit
        setTimeout(() => {
            if (startSocket) startSocket.close();
            startSocket = startMicrophone = startProcessor = null;
            
            const text = startQueryInput.value.trim();
            console.log('[Start screen] Ready to submit, text:', text);
            
            // Save voice metadata to backend
            if (text && startVoiceMetadata.words.length > 0) {
                console.log('[Start screen] Saving voice metadata...');
                fetch('/save_voice_metadata', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        transcript: text,
                        metadata: startVoiceMetadata
                    })
                }).then(r => r.json())
                  .then(d => console.log('[Start screen] Voice metadata saved:', d))
                  .catch(err => console.error('[Start screen] Failed to save metadata:', err));
            }
            
            if (text) {
                startQueryInput.placeholder = "Submitting...";
                startSendBtn.click();
            } else {
                startQueryInput.placeholder = "Ask a question...";
                startIsSubmitting = false; // Reset if no submission
            }
        }, 500); // Reduced delay
    }
    
    // Start screen chunked recording functions
    async function startScreenChunkedRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json(); 
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid; 
            isRecording = true; 
            startMicBtn.classList.add('recording');
            startQueryInput.placeholder = "Recording... Click mic to stop.";
            
            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch {}
                }
            });
            mediaRecorder.start(2000);
        } catch (err) { 
            alert('Unable to access microphone: ' + err.message); 
        }
    }
    
    async function stopStartScreenChunkedRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false; 
        mediaRecorder.stop(); 
        mediaRecorder.stream.getTracks().forEach(t=>t.stop());
        startMicBtn.classList.remove('recording');
        startQueryInput.placeholder = "Finalizing transcription...";
        
        try { 
            const res2 = await fetch('/stt/stop', { method: 'POST' }); 
            const data = await res2.json(); 
            if (data.text) { 
                startQueryInput.value = data.text;
                // Auto-submit after transcription completes
                startSendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (err) {
            console.error('Failed to stop STT session:', err);
            alert('An error occurred while finalizing transcription.');
        } finally {
            startQueryInput.placeholder = "Ask a question...";
            mediaRecorder = null;
            sttSid = null;
        }
    }
    
    // Start screen mic button - checks backend and routes appropriately
    startMicBtn?.addEventListener('click', async ()=>{
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopStartScreenDeepgramStreaming(); 
            else await startScreenDeepgramStreaming();
        } else {
            if (isRecording) await stopStartScreenChunkedRecording(); 
            else await startScreenChunkedRecording();
        }
    });
    // --- Voice Input: Conditional logic for STT backend ---
    const sttBackend = '{{ stt_backend }}';
    const micBtn = document.getElementById('mic-btn');
    const queryInput = document.getElementById('query-input');
    const sendBtn = document.querySelector('#query-form button[type="submit"]');

    // --- Logic for Deepgram Streaming STT ---
    let socket;
    let microphone;
    let processor;

    async function startDeepgramStreaming() {
        isRecording = true;
        micBtn.classList.add('recording');
        queryInput.placeholder = "ðŸŽ¤ Starting real-time conversation... Speak naturally!";

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphone = stream;

            const wsUrl = (window.location.protocol === 'https:' ? 'wss://' : 'ws://') + window.location.host + '/stt/deepgram';
            socket = new WebSocket(wsUrl);

            socket.onopen = async () => {
                console.log('WebSocket connected for Deepgram streaming.');
                try {
                    // Use MediaRecorder with a more compatible format
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/ogg;codecs=opus';
                    }
                    
                    const mediaRecorder = new MediaRecorder(microphone, { 
                        mimeType: mimeType,
                        audioBitsPerSecond: 16000 
                    });
                    
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0 && socket.readyState === WebSocket.OPEN) {
                            console.log('Sending audio chunk, size:', event.data.size);
                            socket.send(event.data);
                        }
                    };
                    
                    mediaRecorder.onerror = (event) => {
                        console.error('MediaRecorder error:', event.error);
                    };
                    
                    mediaRecorder.start(250); // Send chunks every 250ms for better stability and less load
                    processor = mediaRecorder; // Store reference for cleanup
                    
                } catch (error) {
                    console.error('Error setting up MediaRecorder:', error);
                    socket.close();
                }
            };

            socket.onmessage = (event) => {
                console.log('Received WebSocket message:', event.data);
                try {
                    const data = JSON.parse(event.data);
                    
                    if (data.transcript) {
                        // Real-time transcript updates
                        queryInput.value = data.transcript;
                        
                        if (data.interim) {
                            queryInput.style.fontStyle = 'italic';
                            queryInput.style.opacity = '0.8';
                        } else {
                            queryInput.style.fontStyle = 'normal';
                            queryInput.style.opacity = '1';
                            // Don't add user message here - wait for LLM response
                        }
                        
                        console.log('Real-time transcript:', data.transcript, data.interim ? '(interim)' : '(final)');
                        
                    } else if (data.llm_response) {
                        // LLM interjected with a response
                        console.log('LLM interjection:', data.llm_response);
                        
                        const conversation = document.getElementById('query-conversation');
                        
                        // First add the user message (the complete transcript that triggered the response)
                        if (queryInput.value.trim()) {
                            const userMessage = document.createElement('div');
                            userMessage.className = 'message-user';
                            userMessage.textContent = queryInput.value.trim();
                            conversation.appendChild(userMessage);
                        }
                        
                        // Then add LLM response
                        const botMessage = document.createElement('div');
                        botMessage.className = 'message-bot';
                        botMessage.textContent = data.llm_response;
                        conversation.appendChild(botMessage);
                        conversation.scrollTop = conversation.scrollHeight;
                        
                        // Clear the input to continue listening for new speech
                        queryInput.value = '';
                        queryInput.placeholder = 'ðŸŽ¤ Continue speaking... AI is listening';
                        
                    } else if (data.error) {
                        console.error('WebSocket error:', data.error);
                        alert('Streaming error: ' + data.error);
                    } else if (data.status) {
                        console.log('WebSocket status:', data.message);
                        queryInput.placeholder = 'ðŸŽ¤ Real-time conversation active - speak naturally!';
                    }
                } catch (e) {
                    console.error('Error parsing WebSocket message:', e);
                }
            };

            socket.onclose = (event) => {
                console.log('WebSocket closed:', event.code, event.reason);
                if (isRecording) {
                    console.log('WebSocket closed unexpectedly during recording');
                    // Don't auto-reconnect, let user restart manually
                }
            };
            socket.onerror = (err) => {
                console.error('WebSocket error:', err);
                if (isRecording) {
                    console.log('WebSocket error during recording, stopping...');
                    stopDeepgramStreaming();
                }
            };

        } catch (err) {
            console.error('Mic/WebSocket error:', err);
            alert('Unable to access microphone or connect to streaming service: ' + err.message);
            await stopDeepgramStreaming(); // Cleanup on error
        }
    }

    async function stopDeepgramStreaming() {
        if (socket) socket.close();
        if (processor && processor.stop) processor.stop(); // Stop MediaRecorder
        if (microphone) microphone.getTracks().forEach(track => track.stop());
        isRecording = false;
        micBtn.classList.remove('recording');
        queryInput.placeholder = "Enter your query or use the mic...";
        
        // End the conversation session
        console.log('Ending real-time conversation session');
        queryInput.placeholder = "Real-time conversation ended. Click mic to start again.";
        
        socket = microphone = processor = null;
    }

    // --- Logic for chunked recording (Whisper/Gemini) ---
    let mediaRecorder = null;
    let sttSid = null;

    function chooseAudioMime() {
        const options = ['audio/webm;codecs=opus', 'audio/webm', 'audio/ogg;codecs=opus', 'audio/ogg'];
        for (const t of options) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
        }
        return '';
    }

    function extForMime(m) {
        if (!m) return 'webm';
        if (m.includes('ogg')) return 'ogg';
        return 'webm';
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json();
            if (!res.ok || !data0.stt_sid) throw new Error(data0.error || 'Failed to start STT session');
            sttSid = data0.stt_sid;
            if (sendBtn) sendBtn.disabled = true;

            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try { await fetch('/stt/chunk', { method: 'POST', body: fd }); } catch (err) { console.error('Chunk upload failed', err); }
                }
            });

            mediaRecorder.start(2000);
            isRecording = true;
            micBtn.classList.add('recording');
            queryInput.placeholder = "Recording... Click mic to stop.";
        } catch (err) {
            console.error('Mic error:', err);
            alert('Unable to access microphone: ' + err.message);
        }
    }

    async function stopRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;
        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        micBtn.classList.remove('recording');
        if (sendBtn) sendBtn.disabled = false;
        queryInput.placeholder = "Finalizing transcription...";

        try {
            const res = await fetch('/stt/stop', { method: 'POST' });
            const data = await res.json();
            if (data.text) {
                queryInput.value = data.text;
                sendBtn.click();
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (e) {
            console.error('Failed to stop STT session:', e);
            alert('An error occurred while finalizing transcription.');
        } finally {
            queryInput.placeholder = "Enter your query or use the mic...";
            mediaRecorder = null;
            sttSid = null;
        }
    }

    // Main mic button event listener
    micBtn?.addEventListener('click', async () => {
        if (sttBackend === 'deepgram_streaming') {
            if (isRecording) await stopDeepgramStreaming(); else await startDeepgramStreaming();
        } else {
            if (isRecording) await stopRecording(); else await startRecording();
        }
    });

    document.getElementById('query-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const queryInput = document.getElementById('query-input');
            const query = queryInput.value.trim();
            if (!query) return;
            lastUserQueryText = query;

            // Display user message
            const conversation = document.getElementById('query-conversation');
            const userMessage = document.createElement('div');
            userMessage.className = 'message-user';
            userMessage.textContent = query;
            conversation.appendChild(userMessage);
            conversation.scrollTop = conversation.scrollHeight;

            // Log turn
            conversationLog.push({
                turn: conversationLog.length + 1,
                role: 'user',
                inputType: 'text',
                content: query,
                timestamp: new Date().toISOString()
            });

            // Clear input
            queryInput.value = '';

            // Update left rail context
            updateLatestPromptPanel(query);
            refreshRelatedSuggestions(query);

            //send query to backend
            const queryData = new FormData();
            queryData.append('query', query);

            fetch ('/query', {
                method: 'POST',
                body: queryData
            })
            .then(response => response.json())
            .then(data => {
                // Display bot response
                const botMessage = document.createElement('div');
                botMessage.className = 'message-bot';
                botMessage.textContent = data.response || (data.error ? ('Error: ' + data.error) : '');
                conversation.appendChild(botMessage);
                conversation.scrollTop = conversation.scrollHeight;

                // Log bot turn
                conversationLog.push({
                    turn: conversationLog.length + 1,
                    role: 'assistant',
                    inputType: 'model',
                    content: botMessage.textContent,
                    timestamp: new Date().toISOString()
                });
            })
            .catch(error => {
                console.error('Error during backend query:', error);
            });
        });

        // Save chat button handler
        document.getElementById('save-chat-btn').addEventListener('click', function() {
            const payload = {
                sessionInfo: {
                    sessionId: crypto.randomUUID(),
                    userId: 'anonymous',
                    startTimestamp: sessionStart,
                    endTimestamp: new Date().toISOString(),
                    llmModel: 'gemini-1.5-flash-latest'
                },
                context: {
                    initialContent: latestUserPrompt || '',
                    finalContent: conversationLog.length ? conversationLog[conversationLog.length - 1].content : ''
                },
                conversationLog: conversationLog,
                evaluation: {
                    surveyResponses: {},
                    userComments: ''
                }
            };
            fetch('/save_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(d => {
                if (d.error) {
                    alert('Failed to save: ' + d.error);
                } else {
                    alert('Saved: ' + d.dirName);
                }
            })
            .catch(err => {
                alert('Save error: ' + err);
            });
        });

        // --- Similarity helpers (trigram + cosine) ---
        function trigramVector(text){
            const v = new Map();
            const t = (text || '').toLowerCase();
            for (let i=0;i<t.length-2;i++){
                const tri = t.slice(i,i+3);
                v.set(tri, (v.get(tri)||0)+1);
            }
            return v;
        }
        function wordVector(text){
            const v = new Map();
            const tokens = (text||'').toLowerCase().split(/[^a-z0-9]+/).filter(Boolean);
            for (const tok of tokens){ v.set(tok, (v.get(tok)||0)+1); }
            return v;
        }
        function cosineSim(v1, v2){
            if (!v1 || !v2) return 0;
            let dot=0, norm1=0, norm2=0;
            for (const [,w] of v1) norm1 += w*w;
            for (const [,w] of v2) norm2 += w*w;
            const smaller = v1.size < v2.size ? v1 : v2;
            const other = smaller===v1 ? v2 : v1;
            for (const [k,w] of smaller){ const w2 = other.get(k)||0; if (w2) dot += w*w2; }
            if (!norm1 || !norm2) return 0;
            return dot / (Math.sqrt(norm1)*Math.sqrt(norm2));
        }
        function buildKeywordTopicIndex(topics){
            if (!Array.isArray(topics)) return;
            keywordTopicItems = topics.slice();
            keywordTopicIndex = keywordTopicItems.map(t => {
                const text = [t.title, t.description, ...(t.functions||[]).map(f=>`${f.name} ${f.description}`)].join(' ').toLowerCase();
                const synonyms = new Set((TOPIC_SYNONYM_MAP[t.id] || []).map(s => s.toLowerCase()));
                const tokens = new Set(text.split(/[^a-z0-9]+/).filter(Boolean));
                synonyms.forEach(s => tokens.add(s));
                return {
                    topic: t,
                    triVector: trigramVector(text),
                    wordVector: wordVector(text),
                    tokens,
                    synonyms
                };
            });
        }

        function keywordTopicFallback(prompt){
            const q = (prompt || '').toLowerCase();
            if (!q || !keywordTopicIndex.length) return keywordTopicItems.slice(0, 3).map(t => ({ title: t.title, description: t.description || '' }));
            const qTri = trigramVector(q);
            const qWord = wordVector(q);
            const qTokens = new Set(q.split(/[^a-z0-9]+/).filter(Boolean));
            const scored = keywordTopicIndex.map(entry => {
                const tri = cosineSim(qTri, entry.triVector);
                const word = cosineSim(qWord, entry.wordVector);
                let boost = 0;
                qTokens.forEach(tok => {
                    if (entry.tokens.has(tok)) boost += 0.04;
                    if (entry.synonyms.has(tok)) boost += 0.08;
                });
                return { entry, score: (0.6 * tri) + (0.4 * word) + boost };
            }).sort((a,b)=>b.score - a.score);
            const filtered = scored.filter(s => s.score > 0.01).slice(0, 3);
            const picks = filtered.length ? filtered : scored.slice(0, 3);
            const mapped = picks.map(item => ({
                title: item.entry.topic.title,
                description: item.entry.topic.description || ''
            })).filter(t => t.title);
            if (!mapped.length){
                return ALL_TOPICS.slice(0, 3).map(t => ({ title: t.title, description: t.desc || '' }));
            }
            return mapped;
        }

        function updateLatestPromptPanel(text){
            if (typeof text === 'string') {
                latestUserPrompt = text.trim();
            }
            const panel = document.getElementById('latest-prompt-panel');
            const content = document.getElementById('latest-prompt-content');
            if (!panel || !content) return;
            if (latestUserPrompt){
                content.textContent = latestUserPrompt;
                panel.classList.remove('hidden');
            } else {
                content.textContent = '';
                panel.classList.add('hidden');
            }
        }

        function renderFollowupExamples(followUps){
            const panel = document.getElementById('followup-panel');
            const list = document.getElementById('followup-list');
            if (!panel || !list) return;
            list.innerHTML = '';
            const items = Array.isArray(followUps) ? followUps.filter(Boolean).map(f => String(f).trim()).filter(Boolean).slice(0, 2) : [];
            if (!items.length){
                panel.classList.add('hidden');
                return;
            }
            for (const q of items){
                const li = document.createElement('li');
                li.textContent = q;
                list.appendChild(li);
            }
            panel.classList.remove('hidden');
        }

        function renderRelatedTopics(topics){
            const panel = document.getElementById('related-topics-panel');
            const list = document.getElementById('related-topics-list');
            if (!panel || !list) return;
            list.innerHTML = '';
            const items = Array.isArray(topics) ? topics.filter(Boolean).slice(0, 3) : [];
            if (!items.length){
                panel.classList.add('hidden');
                return;
            }
            items.forEach(t => {
                const item = document.createElement('div');
                item.className = 'related-topic-item';
                const title = document.createElement('div');
                title.className = 'related-topic-title';
                title.textContent = t.title || '';
                const desc = document.createElement('div');
                desc.className = 'related-topic-desc';
                desc.textContent = t.description || '';
                item.appendChild(title);
                if (desc.textContent) item.appendChild(desc);
                list.appendChild(item);
            });
            panel.classList.remove('hidden');
        }

        async function refreshRelatedSuggestions(prompt){
            const trimmed = (prompt || '').trim();
            const requestToken = ++relatedFetchToken;
            if (!trimmed){
                relatedTopicsState.topics = [];
                relatedTopicsState.followUps = [];
                relatedTopicsState.source = 'none';
                renderRelatedTopics([]);
                renderFollowupExamples([]);
                return;
            }
            try {
                const res = await fetch('/related_topics', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ prompt: trimmed })
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                const data = await res.json();
                if (requestToken !== relatedFetchToken) return;
                relatedTopicsState.topics = Array.isArray(data.topics) ? data.topics : [];
                relatedTopicsState.followUps = Array.isArray(data.followUps) ? data.followUps : [];
                relatedTopicsState.source = data.source || 'unknown';
                if (!relatedTopicsState.topics.length){
                    relatedTopicsState.topics = keywordTopicFallback(trimmed);
                }
                renderRelatedTopics(relatedTopicsState.topics);
                renderFollowupExamples(relatedTopicsState.followUps);
            } catch (err) {
                console.error('Failed to fetch related topics', err);
                if (requestToken !== relatedFetchToken) return;
                relatedTopicsState.topics = keywordTopicFallback(trimmed);
                relatedTopicsState.followUps = [];
                relatedTopicsState.source = 'fallback-client';
                renderRelatedTopics(relatedTopicsState.topics);
                renderFollowupExamples([]);
            }
        }

        // Draggable resizer
        const resizer = document.getElementById('resizer');
        const leftPanel = document.querySelector('.left-panel');
        const rightPanel = document.querySelector('.right-panel');

        const resize = (e) => {
            const isHorizontal = window.innerWidth > 768;
            if (isHorizontal) {
                const newWidth = e.clientX;
                if (newWidth > 200 && newWidth < window.innerWidth - 200) {
                    leftPanel.style.flexBasis = `${newWidth}px`;
                }
            } else {
                const newHeight = e.clientY;
                if (newHeight > 100 && newHeight < window.innerHeight - 100) {
                    leftPanel.style.flexBasis = `${newHeight}px`;
                    leftPanel.style.height = `${newHeight}px`;
                }
            }
        };

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', resize);
            });
        });
</script>
</body>
</html>