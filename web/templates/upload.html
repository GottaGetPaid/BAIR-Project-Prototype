<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
</head>
<body>
    <div class="main-container">
        <div class="left-panel">
        <div class="top-bar">
            <div>
                <div class="title">Model Resources</div>
                <div class="subtle">See what functions and tools are being used</div>
            </div>
            <button id="theme-toggle" class="btn btn-ghost" title="Toggle dark mode">ðŸŒ™</button>
        </div>
        <div id="json-meta"></div>
        <div id="entry-list-container" class="hidden">
            <div class="section-title">Entries</div>
            <div id="entry-list"></div>
        </div>
    <div class="section-title inline-controls"><span>Tools & Toolboxes</span></div>
    <div id="toolbox-view"></div>
        <div class="section-title inline-controls">
            <span>Raw JSON</span>
            <button id="toggle-raw-btn" class="btn btn-ghost" style="padding: 4px 8px; font-size: 12px;">Show</button>
        </div>
        <pre id="json-content" class="hidden"></pre>
    </div>

    <div id="resizer"></div>

    <div class="right-panel">
        <div class="form-container query-form-container">
            <h3>Query Interface</h3>
            <div id="query-conversation" class="query-conversation">
                </div>
            <form id="query-form" class="query-form">
                <input type="text" id="query-input" placeholder="Enter your query or use the mic...">
                <button type="button" id="mic-btn" class="mic-btn" title="Start/Stop voice">ðŸŽ¤</button>
                <button type="submit">Send</button>
            </form>
        </div>

        <div class="form-container upload-form-container">
            <h3>Upload a JSON or JSONLfile</h3>
            <form id="upload-form">
                <input type="file" name="file" id="file-input" accept=".json,.jsonl">
                <button type="submit" class="btn btn-primary">Upload</button>
            </form>
            <button id="save-chat-btn" class="btn" style="margin-top:10px;">Save Chat</button>
        </div>
    </div>
</div>
<script>
    // Theme handling
    (function initTheme(){
        const saved = localStorage.getItem('theme') || 'light';
        if (saved === 'dark') document.documentElement.setAttribute('data-theme','dark');
        const btn = document.getElementById('theme-toggle');
        const setIcon = () => { btn.textContent = document.documentElement.getAttribute('data-theme') === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™'; };
        setIcon();
        btn.addEventListener('click', ()=>{
            const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
            const next = cur === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', next === 'dark' ? 'dark' : '');
            localStorage.setItem('theme', next);
            setIcon();
        });
    })();

    // Track conversation log for saving later
    const conversationLog = [];
    let sessionStart = new Date().toISOString();
    let lastParsed = null;

    // Raw JSON toggler
    const rawPre = document.getElementById('json-content');
    const rawBtn = document.getElementById('toggle-raw-btn');
    rawBtn.addEventListener('click', ()=>{
        const hidden = rawPre.classList.toggle('hidden');
        rawBtn.textContent = hidden ? 'Show' : 'Hide';
    });

    // Voice input via MediaRecorder -> chunked upload -> STT backend
    let mediaRecorder = null;
    let isRecording = false;
    let sttSid = null;

    const micBtn = document.getElementById('mic-btn');
    const queryInput = document.getElementById('query-input');
    const sendBtn = document.querySelector('#query-form button[type="submit"]');

    function chooseAudioMime() {
        const options = [
            'audio/webm;codecs=opus', 'audio/webm',
            'audio/ogg;codecs=opus', 'audio/ogg'
        ];
        for (const t of options) {
            if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
        }
        return '';
    }

    function extForMime(m) {
        if (!m) return 'webm';
        if (m.includes('ogg')) return 'ogg';
        return 'webm';
    }

    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const mimeType = chooseAudioMime();
            mediaRecorder = mimeType ? new MediaRecorder(stream, { mimeType }) : new MediaRecorder(stream);
            
            const res = await fetch('/stt/start', { method: 'POST' });
            const data0 = await res.json();
            if (!res.ok || !data0.stt_sid) {
                throw new Error(data0.error || 'Failed to start STT session');
            }
            sttSid = data0.stt_sid;
            if (sendBtn) sendBtn.disabled = true;

            mediaRecorder.addEventListener('dataavailable', async (e) => {
                if (e.data && e.data.size > 0 && isRecording) {
                    const fd = new FormData();
                    const ext = extForMime(mediaRecorder.mimeType);
                    const file = new File([e.data], `chunk_${Date.now()}.${ext}`, { type: mediaRecorder.mimeType });
                    fd.append('audio', file);
                    try {
                        // Just send the chunk, don't expect a transcription back
                        await fetch('/stt/chunk', { method: 'POST', body: fd });
                    } catch (err) { console.error('Chunk upload failed', err); }
                }
            });

            mediaRecorder.start(2000); // Send a chunk every 2 seconds
            isRecording = true;
            micBtn.classList.add('recording');
            queryInput.placeholder = "Recording... Click mic to stop.";
        } catch (err) {
            console.error('Mic error:', err);
            alert('Unable to access microphone: ' + err.message);
        }
    }

    async function stopRecording() {
        if (!mediaRecorder || mediaRecorder.state === 'inactive') return;

        isRecording = false;
        mediaRecorder.stop();
        mediaRecorder.stream.getTracks().forEach(t => t.stop());
        micBtn.classList.remove('recording');
        if (sendBtn) sendBtn.disabled = false;
        queryInput.placeholder = "Finalizing transcription...";

        try {
            const res = await fetch('/stt/stop', { method: 'POST' });
            const data = await res.json();
            if (data.text) {
                queryInput.value = data.text;
                sendBtn.click(); // Automatically submit the form
            } else if (data.error) {
                console.error('STT error:', data.error);
                alert('Transcription failed: ' + data.error);
            }
        } catch (e) {
            console.error('Failed to stop STT session:', e);
            alert('An error occurred while finalizing transcription.');
        } finally {
            queryInput.placeholder = "Enter your query or use the mic...";
            mediaRecorder = null;
            sttSid = null;
        }
    }

    micBtn?.addEventListener('click', async () => {
        if (!isRecording) await startRecording(); else await stopRecording();
    });

 
    document.getElementById('upload-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert("Please select a file.");
                return;
            }

            //display raw json
            const reader = new FileReader();
            reader.onload = function(event) {
                const rawText = event.target.result;
                document.getElementById('json-content').textContent = rawText;
            };
            reader.onerror = function(event) {
                alert("Error reading: " + event.target.error.name);
            };
            reader.readAsText(file);

            //send to backend for JSON parsing and UI hydration
            const formData = new FormData();
            formData.append('file', file);

            fetch('/upload_json', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                if (data.error) {
                    console.error('JSON parse error:', data.error);
                    alert('JSON parse error: ' + data.error);
                    return;
                }
                console.log(data.message);
                const entries = data.parsed_list || [];
                if (!entries.length) return;

                const entryListContainer = document.getElementById('entry-list-container');
                const entryList = document.getElementById('entry-list');

                if (entries.length > 1) {
                    entryListContainer.classList.remove('hidden');
                    entryList.innerHTML = '';
                    entries.forEach((entry, index) => {
                        const btn = document.createElement('button');
                        btn.textContent = entry.id || `Entry ${index + 1}`;
                        btn.className = 'btn entry-btn';
                        btn.addEventListener('click', () => {
                            renderEntry(entry);
                            document.querySelectorAll('.entry-btn').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                        });
                        entryList.appendChild(btn);
                    });
                } else {
                    entryListContainer.classList.add('hidden');
                }

                // Render the first entry by default
                renderEntry(entries[0]);
                if (entryList.firstChild) {
                    entryList.firstChild.classList.add('active');
                }
            })
            .catch(error => {
                console.error('Error during backend JSON upload:', error);
            });
        });

        document.getElementById('query-form').addEventListener('submit', function(e) {
            e.preventDefault();

            const queryInput = document.getElementById('query-input');
            const query = queryInput.value.trim();
            if (!query) return;

            // Display user message
            const conversation = document.getElementById('query-conversation');
            const userMessage = document.createElement('div');
            userMessage.className = 'message-user';
            userMessage.textContent = query;
            conversation.appendChild(userMessage);
            conversation.scrollTop = conversation.scrollHeight;

            // Log turn
            conversationLog.push({
                turn: conversationLog.length + 1,
                role: 'user',
                inputType: 'text',
                content: query,
                timestamp: new Date().toISOString()
            });

            // Clear input
            queryInput.value = '';

            //send query to backend
            const queryData = new FormData();
            queryData.append('query', query);

            fetch ('/query', {
                method: 'POST',
                body: queryData
            })
            .then(response => response.json())
            .then(data => {
                // Display bot response
                const botMessage = document.createElement('div');
                botMessage.className = 'message-bot';
                botMessage.textContent = data.response || (data.error ? ('Error: ' + data.error) : '');
                conversation.appendChild(botMessage);
                conversation.scrollTop = conversation.scrollHeight;

                // Log bot turn
                conversationLog.push({
                    turn: conversationLog.length + 1,
                    role: 'assistant',
                    inputType: 'model',
                    content: botMessage.textContent,
                    timestamp: new Date().toISOString()
                });
            })
            .catch(error => {
                console.error('Error during backend query:', error);
            });
        });

        // Save chat button handler
        document.getElementById('save-chat-btn').addEventListener('click', function() {
            const payload = {
                sessionInfo: {
                    sessionId: crypto.randomUUID(),
                    userId: 'anonymous',
                    startTimestamp: sessionStart,
                    endTimestamp: new Date().toISOString(),
                    llmModel: 'gemini-1.5-flash-latest'
                },
                context: {
                    initialContent: lastParsed?.questionText || '',
                    finalContent: conversationLog.length ? conversationLog[conversationLog.length - 1].content : ''
                },
                conversationLog: conversationLog,
                evaluation: {
                    surveyResponses: {},
                    userComments: ''
                }
            };
            fetch('/save_chat', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            })
            .then(r => r.json())
            .then(d => {
                if (d.error) {
                    alert('Failed to save: ' + d.error);
                } else {
                    alert('Saved: ' + d.dirName);
                }
            })
            .catch(err => {
                alert('Save error: ' + err);
            });
        });

        function renderEntry(entry) {
            lastParsed = entry;

            // Populate left side meta and functions
            const metaDiv = document.getElementById('json-meta');
            metaDiv.innerHTML = '';
            const idP = document.createElement('p');
            idP.textContent = 'ID: ' + (entry.id || '(none)');
            const qP = document.createElement('p');
            qP.textContent = 'Question: ' + (entry.questionText || '');
            metaDiv.appendChild(idP);
            metaDiv.appendChild(qP);

            document.getElementById('json-content').textContent = JSON.stringify(entry.raw, null, 2);

            renderToolboxView(entry.functions || []);

            // Add a button to submit the question to the chat
            const submitBtn = document.createElement('button');
            submitBtn.textContent = 'Submit Question';
            submitBtn.className = 'btn submit-question-btn';
            submitBtn.addEventListener('click', () => {
                const q = (entry.questionText || '').trim();
                if (q) {
                    const queryInput = document.getElementById('query-input');
                    queryInput.value = q;
                    document.querySelector('#query-form button[type="submit"]').click();
                }
            });
            metaDiv.appendChild(submitBtn);
        }

        // Build toolbox view (group by toolbox prefix of name)
        function renderToolboxView(functions){
            const container = document.getElementById('toolbox-view');
            container.innerHTML = '';
            if (!functions || !functions.length){
                const p = document.createElement('p'); p.className = 'subtle'; p.textContent = 'No tools found in JSON.'; container.appendChild(p); return;
            }
            const groups = {};
            for (const fn of functions){
                const full = (fn.name || '').trim();
                let toolbox = 'misc';
                let tool = full || '(unnamed)';
                if (full.includes('.')){
                    const idx = full.indexOf('.');
                    toolbox = full.slice(0, idx) || 'misc';
                    tool = full.slice(idx+1) || '(unnamed)';
                }
                if (!groups[toolbox]) groups[toolbox] = [];
                groups[toolbox].push({ tool, desc: fn.description || '', params: fn.parameters });
            }

            const toolboxNames = Object.keys(groups).sort((a,b)=>a.localeCompare(b));
            for (const name of toolboxNames){
                const items = groups[name];
                const details = document.createElement('details');
                details.className = 'toolbox';
                // Keep closed by default to avoid clutter
                const summary = document.createElement('summary');
                summary.innerHTML = `${name} <span class="badge">${items.length}</span>`;
                details.appendChild(summary);
                const ul = document.createElement('ul');
                ul.className = 'tool-list';
                for (const it of items){
                    const li = document.createElement('li');
                    const d = document.createElement('details'); d.className = 'tool';
                    const s = document.createElement('summary'); s.textContent = it.tool; d.appendChild(s);
                    if (it.desc){ const desc = document.createElement('div'); desc.className = 'tool-desc'; desc.textContent = it.desc; d.appendChild(desc); }
                    if (it.params){ const pre = document.createElement('pre'); pre.className = 'tool-params'; pre.textContent = JSON.stringify(it.params, null, 2); d.appendChild(pre); }
                    li.appendChild(d);
                    ul.appendChild(li);
                }
                details.appendChild(ul);
                container.appendChild(details);
            }
        }

        // Draggable resizer
        const resizer = document.getElementById('resizer');
        const leftPanel = document.querySelector('.left-panel');
        const rightPanel = document.querySelector('.right-panel');

        const resize = (e) => {
            const isHorizontal = window.innerWidth > 768;
            if (isHorizontal) {
                const newWidth = e.clientX;
                if (newWidth > 200 && newWidth < window.innerWidth - 200) {
                    leftPanel.style.flexBasis = `${newWidth}px`;
                }
            } else {
                const newHeight = e.clientY;
                if (newHeight > 100 && newHeight < window.innerHeight - 100) {
                    leftPanel.style.flexBasis = `${newHeight}px`;
                    leftPanel.style.height = `${newHeight}px`;
                }
            }
        };

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();
            document.addEventListener('mousemove', resize);
            document.addEventListener('mouseup', () => {
                document.removeEventListener('mousemove', resize);
            });
        });
</script>
</body>
</html>